// Generated by CoffeeScript 1.10.0
var abs, calc_chrscales, calc_crosstab, chrscales, ci_by_group, colSums, count_groups, d3panels, displayError, expand2vector, forceAsArray, formatAxis, getLeftRight, jiggle, log10, log2, matrixExtent, matrixMax, matrixMaxAbs, matrixMin, maxdiff, mean_by_group, median, missing2null, pullVarAsArray, reorgLodData, rowSums, sd_by_group, selectGroupColors, sumArray, transpose, unique;

d3panels = {
  version: "1.0.0"
};

formatAxis = function(d, extra_digits) {
  var gap, ndig;
  if (extra_digits == null) {
    extra_digits = 0;
  }
  gap = d[0] != null ? d[1] - d[0] : d[2] - d[1];
  ndig = Math.floor(log10(gap));
  if (ndig > 0) {
    ndig = 0;
  }
  ndig = Math.abs(ndig) + extra_digits;
  return function(val) {
    if ((val != null) && val !== "NA") {
      return d3.format("." + ndig + "f")(val);
    }
    return "NA";
  };
};

unique = function(x) {
  var k, len, output, results, v;
  output = {};
  for (k = 0, len = x.length; k < len; k++) {
    v = x[k];
    if (v != null) {
      output[v] = v;
    }
  }
  results = [];
  for (v in output) {
    results.push(output[v]);
  }
  return results;
};

pullVarAsArray = function(data, variable) {
  var i, results;
  results = [];
  for (i in data) {
    results.push(data[i][variable]);
  }
  return results;
};

reorgLodData = function(data) {
  var chr, i, k, len, ref;
  data.posByChr = {};
  data.lodByChr = {};
  ref = data.chrname;
  for (i = k = 0, len = ref.length; k < len; i = ++k) {
    chr = ref[i];
    data.posByChr[chr] = (function() {
      var results;
      results = [];
      for (i in data.pos) {
        if (data.chr[i] === chr) {
          results.push(data.pos[i]);
        }
      }
      return results;
    })();
    data.lodByChr[chr] = (function() {
      var results;
      results = [];
      for (i in data.pos) {
        if (data.chr[i] === chr) {
          results.push(data.lod[i]);
        }
      }
      return results;
    })();
  }
  data.markerinfo = (function() {
    var results;
    results = [];
    for (i in data.marker) {
      if (data.marker[i] !== "") {
        results.push({
          name: data.marker[i],
          chr: data.chr[i],
          pos: data.pos[i],
          lod: data.lod[i]
        });
      }
    }
    return results;
  })();
  return data;
};

calc_chrscales = function(plot_width, left_margin, gap, chr, start, end) {
  var chr_end_pixels, chr_length, chr_start_pixels, i, k, n_chr, ref, tot_chr_length, tot_pixels, xscale;
  n_chr = chr.length;
  chr_length = (function() {
    var results;
    results = [];
    for (i in end) {
      results.push(end[i] - start[i]);
    }
    return results;
  })();
  tot_chr_length = chr_length.reduce(function(t, s) {
    return t + s;
  });
  tot_pixels = plot_width - gap * n_chr;
  chr_start_pixels = [left_margin + gap / 2];
  chr_end_pixels = [left_margin + gap / 2 + tot_pixels / tot_chr_length * chr_length[0]];
  for (i = k = 1, ref = n_chr - 1; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
    chr_start_pixels.push(chr_end_pixels[i - 1] + gap);
    chr_end_pixels.push(chr_start_pixels[i] + tot_pixels / tot_chr_length * chr_length[i]);
  }
  xscale = {};
  for (i in chr) {
    xscale[chr[i]] = d3.scale.linear().domain([start[i], end[i]]).range([chr_start_pixels[i], chr_end_pixels[i]]);
  }
  return xscale;
};

chrscales = function(data, width, chrGap, leftMargin, pad4heatmap) {
  var L, chr, chrEnd, chrLength, chrStart, cur, d, i, k, l, len, len1, maxd, ref, ref1, rng, totalChrLength, w;
  chrStart = [];
  chrEnd = [];
  chrLength = [];
  totalChrLength = 0;
  maxd = 0;
  ref = data.chrnames;
  for (k = 0, len = ref.length; k < len; k++) {
    chr = ref[k];
    d = maxdiff(data.posByChr[chr]);
    if (d > maxd) {
      maxd = d;
    }
    rng = d3.extent(data.posByChr[chr]);
    chrStart.push(rng[0]);
    chrEnd.push(rng[1]);
    L = rng[1] - rng[0];
    chrLength.push(L);
    totalChrLength += L;
  }
  if (pad4heatmap) {
    data.recwidth = maxd;
    chrStart = chrStart.map(function(x) {
      return x - maxd / 2;
    });
    chrEnd = chrEnd.map(function(x) {
      return x + maxd / 2;
    });
    chrLength = chrLength.map(function(x) {
      return x + maxd;
    });
    totalChrLength += chrLength.length * maxd;
  }
  data.chrStart = [];
  data.chrEnd = [];
  cur = leftMargin;
  if (!pad4heatmap) {
    cur += chrGap / 2;
  }
  data.xscale = {};
  ref1 = data.chrnames;
  for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
    chr = ref1[i];
    data.chrStart.push(cur);
    w = Math.round((width - chrGap * (data.chrnames.length - pad4heatmap)) / totalChrLength * chrLength[i]);
    data.chrEnd.push(cur + w);
    cur = data.chrEnd[i] + chrGap;
    data.xscale[chr] = d3.scale.linear().domain([chrStart[i], chrEnd[i]]).range([data.chrStart[i], data.chrEnd[i]]);
  }
  return data;
};

selectGroupColors = function(ngroup, palette) {
  if (ngroup === 0) {
    return [];
  }
  if (palette === "dark") {
    if (ngroup === 1) {
      return ["slateblue"];
    }
    if (ngroup === 2) {
      return ["MediumVioletRed", "slateblue"];
    }
    if (ngroup === 3) {
      return ["MediumVioletRed", "MediumSeaGreen", "slateblue"];
    }
    if (ngroup <= 9) {
      return colorbrewer.Set1[ngroup];
    }
    return d3.scale.category20().range().slice(0, ngroup);
  } else {
    if (ngroup === 1) {
      return ["#bebebe"];
    }
    if (ngroup === 2) {
      return ["lightpink", "lightblue"];
    }
    if (ngroup <= 9) {
      return colorbrewer.Pastel1[ngroup];
    }
    return ["#8fc7f4", "#fed7f8", "#ffbf8e", "#fffbb8", "#8ce08c", "#d8ffca", "#f68788", "#ffd8d6", "#d4a7fd", "#f5f0f5", "#cc968b", "#f4dcd4", "#f3b7f2", "#f7f6f2", "#bfbfbf", "#f7f7f7", "#fcfd82", "#fbfbcd", "#87feff", "#defaf5"].slice(0, ngroup);
  }
};

expand2vector = function(input, n) {
  var i;
  if (input == null) {
    return input;
  }
  if (Array.isArray(input) && input.length >= n) {
    return input;
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (input.length > 1 && n > 1) {
    input = (function() {
      var results;
      results = [];
      for (i in d3.range(n)) {
        results.push(input[i % input.length]);
      }
      return results;
    })();
  }
  if (input.length === 1 && n > 1) {
    input = (function() {
      var results;
      results = [];
      for (i in d3.range(n)) {
        results.push(input[0]);
      }
      return results;
    })();
  }
  return input;
};

median = function(x) {
  var n, xv;
  if (x == null) {
    return null;
  }
  x = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = x.length; k < len; k++) {
      xv = x[k];
      if (xv != null) {
        results.push(xv);
      }
    }
    return results;
  })();
  n = x.length;
  if (!(n > 0)) {
    return null;
  }
  x.sort(function(a, b) {
    return a - b;
  });
  if (n % 2 === 1) {
    return x[(n - 1) / 2];
  }
  return (x[n / 2] + x[(n / 2) - 1]) / 2;
};

getLeftRight = function(x) {
  var i, k, l, len, n, o, ref, ref1, result, v, xdif;
  n = x.length;
  x.sort(function(a, b) {
    return a - b;
  });
  xdif = [];
  result = {};
  for (k = 0, len = x.length; k < len; k++) {
    v = x[k];
    result[v] = {};
  }
  for (i = l = 1, ref = n; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
    xdif.push(x[i] - x[i - 1]);
    result[x[i]].left = x[i - 1];
  }
  for (i = o = 0, ref1 = n - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    result[x[i]].right = x[i + 1];
  }
  xdif = median(xdif);
  result.mediandiff = xdif;
  result[x[0]].left = x[0] - xdif;
  result[x[n - 1]].right = x[n - 1] + xdif;
  result.extent = [x[0] - xdif / 2, x[n - 1] + xdif / 2];
  return result;
};

maxdiff = function(x) {
  var d, i, k, ref, result;
  if (x.length < 2) {
    return null;
  }
  result = x[1] - x[0];
  if (x.length < 3) {
    return result;
  }
  for (i = k = 2, ref = x.length; 2 <= ref ? k < ref : k > ref; i = 2 <= ref ? ++k : --k) {
    d = x[i] - x[i - 1];
    if (d > result) {
      result = d;
    }
  }
  return result;
};

matrixMin = function(mat) {
  var i, j, result;
  result = mat[0][0];
  for (i in mat) {
    for (j in mat[i]) {
      if (!(result != null) || (result > mat[i][j] && (mat[i][j] != null))) {
        result = mat[i][j];
      }
    }
  }
  return result;
};

matrixMax = function(mat) {
  var i, j, result;
  result = mat[0][0];
  for (i in mat) {
    for (j in mat[i]) {
      if (!(result != null) || (result < mat[i][j] && (mat[i][j] != null))) {
        result = mat[i][j];
      }
    }
  }
  return result;
};

matrixMaxAbs = function(mat) {
  var i, j, result;
  result = Math.abs(mat[0][0]);
  for (i in mat) {
    for (j in mat[i]) {
      if (!(result != null) || (result < Math.abs(mat[i][j]) && (mat[i][j] != null))) {
        result = Math.abs(mat[i][j]);
      }
    }
  }
  return result;
};

matrixExtent = function(mat) {
  return [matrixMin(mat), matrixMax(mat)];
};

d3.selection.prototype.moveToFront = function() {
  return this.each(function() {
    return this.parentNode.appendChild(this);
  });
};

d3.selection.prototype.moveToBack = function() {
  return this.each(function() {
    var firstChild;
    firstChild = this.parentNode.firstchild;
    if (firstChild) {
      return this.parentNode.insertBefore(this, firstChild);
    }
  });
};

forceAsArray = function(x) {
  if (x == null) {
    return x;
  }
  if (Array.isArray(x)) {
    return x;
  }
  return [x];
};

missing2null = function(vec, missingvalues) {
  if (missingvalues == null) {
    missingvalues = ['NA', ''];
  }
  return vec.map(function(value) {
    if (missingvalues.indexOf(value) > -1) {
      return null;
    } else {
      return value;
    }
  });
};

displayError = function(message, divid) {
  var div;
  if (divid == null) {
    divid = null;
  }
  div = "div.error";
  if (divid != null) {
    div += "#" + divid;
  }
  if (d3.select(div).empty()) {
    d3.select("body").insert("div", ":first-child").attr("class", "error");
  }
  return d3.select(div).append("p").text(message);
};

sumArray = function(vec) {
  var x;
  vec = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = vec.length; k < len; k++) {
      x = vec[k];
      if (x != null) {
        results.push(x);
      }
    }
    return results;
  })();
  if (!(vec.length > 0)) {
    return null;
  }
  return vec.reduce(function(a, b) {
    return (a * 1) + (b * 1);
  });
};

calc_crosstab = function(data) {
  var col, cs, i, k, l, ncol, nrow, ref, ref1, result, row, rs;
  nrow = data.ycat.length;
  ncol = data.xcat.length;
  result = (function() {
    var k, ref, results;
    results = [];
    for (row = k = 0, ref = nrow; 0 <= ref ? k <= ref : k >= ref; row = 0 <= ref ? ++k : --k) {
      results.push((function() {
        var l, ref1, results1;
        results1 = [];
        for (col = l = 0, ref1 = ncol; 0 <= ref1 ? l <= ref1 : l >= ref1; col = 0 <= ref1 ? ++l : --l) {
          results1.push(0);
        }
        return results1;
      })());
    }
    return results;
  })();
  for (i in data.x) {
    result[data.y[i]][data.x[i]] += 1;
  }
  rs = rowSums(result);
  cs = colSums(result);
  for (i = k = 0, ref = ncol; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    result[nrow][i] = cs[i];
  }
  for (i = l = 0, ref1 = nrow; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
    result[i][ncol] = rs[i];
  }
  result[nrow][ncol] = sumArray(rs);
  return result;
};

rowSums = function(mat) {
  var k, len, results, x;
  results = [];
  for (k = 0, len = mat.length; k < len; k++) {
    x = mat[k];
    results.push(sumArray(x));
  }
  return results;
};

transpose = function(mat) {
  var i, j, k, ref, results;
  results = [];
  for (j = k = 0, ref = mat[0].length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
    results.push((function() {
      var l, ref1, results1;
      results1 = [];
      for (i = l = 0, ref1 = mat.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
        results1.push(mat[i][j]);
      }
      return results1;
    })());
  }
  return results;
};

colSums = function(mat) {
  return rowSums(transpose(mat));
};

log2 = function(x) {
  if (x == null) {
    return x;
  }
  return Math.log(x) / Math.log(2.0);
};

log10 = function(x) {
  if (x == null) {
    return x;
  }
  return Math.log(x) / Math.log(10.0);
};

abs = function(x) {
  if (x == null) {
    return x;
  }
  return Math.abs(x);
};

mean_by_group = function(g, y) {
  var i, means, n;
  means = {};
  n = {};
  for (i in g) {
    if (n[g[i]] != null) {
      if (y[i] != null) {
        means[g[i]] += y[i];
      }
      if (y[i] != null) {
        n[g[i]] += 1;
      }
    } else {
      if (y[i] != null) {
        means[g[i]] = y[i];
      }
      if (y[i] != null) {
        n[g[i]] = 1;
      }
    }
  }
  for (i in means) {
    means[i] /= n[i];
  }
  return means;
};

sd_by_group = function(g, y) {
  var dev, i, means, n, sds;
  means = mean_by_group(g, y);
  sds = {};
  n = {};
  for (i in g) {
    dev = y[i] - means[g[i]];
    if (n[g[i]] != null) {
      if (y[i] != null) {
        sds[g[i]] += dev * dev;
      }
      if (y[i] != null) {
        n[g[i]] += 1;
      }
    } else {
      if (y[i] != null) {
        sds[g[i]] = dev * dev;
      }
      if (y[i] != null) {
        n[g[i]] = 1;
      }
    }
  }
  for (i in sds) {
    sds[i] = n[i] < 2 ? null : Math.sqrt(sds[i] / (n[i] - 1));
  }
  return sds;
};

count_groups = function(g, y) {
  var i, n;
  n = {};
  for (i in g) {
    if (n[g[i]] != null) {
      if (y[i] != null) {
        n[g[i]] += 1;
      }
    } else {
      if (y[i] != null) {
        n[g[i]] = 1;
      }
    }
  }
  return n;
};

ci_by_group = function(g, y, m) {
  var ci, dev, i, means, n, sds;
  if (m == null) {
    m = 2;
  }
  means = mean_by_group(g, y);
  sds = {};
  n = {};
  for (i in g) {
    dev = y[i] - means[g[i]];
    if (n[g[i]] != null) {
      if (y[i] != null) {
        sds[g[i]] += dev * dev;
      }
      if (y[i] != null) {
        n[g[i]] += 1;
      }
    } else {
      if (y[i] != null) {
        sds[g[i]] = dev * dev;
      }
      if (y[i] != null) {
        n[g[i]] = 1;
      }
    }
  }
  for (i in sds) {
    sds[i] = n[i] < 2 ? null : Math.sqrt(sds[i] / (n[i] - 1));
  }
  ci = {};
  for (i in means) {
    ci[i] = {
      mean: means[i],
      low: n[i] > 0 ? means[i] - m * sds[i] / Math.sqrt(n[i]) : means[i],
      high: n[i] > 0 ? means[i] + m * sds[i] / Math.sqrt(n[i]) : means[i]
    };
  }
  return ci;
};

jiggle = function(group, y, radius, height, width) {
  var cat, counts, hamount, i, jit, max_y, min_y, n_group, seen, vamount, vnum, x, ycat, yout, yv;
  n_group = d3.max(group);
  min_y = d3.min(y);
  max_y = d3.max(y);
  vnum = Math.ceil(height / (radius * 2));
  hamount = (radius * 2) / (width / n_group);
  vamount = (max_y - min_y) / vnum;
  ycat = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = y.length; k < len; k++) {
      x = y[k];
      results.push(Math.floor((x - min_y) / vamount));
    }
    return results;
  })();
  counts = {};
  for (i in y) {
    cat = group[i] + ":" + ycat[i];
    counts[cat] = counts[cat] != null ? counts[cat] + 1 : 1;
  }
  seen = {};
  jit = [];
  for (i in y) {
    cat = group[i] + ":" + ycat[i];
    seen[cat] = seen[cat] != null ? seen[cat] + 1 : 1;
    jit.push((seen[cat] - 1) * hamount - (counts[cat] - 1) * hamount / 2);
  }
  yout = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = ycat.length; k < len; k++) {
      yv = ycat[k];
      results.push(yv * vamount + min_y);
    }
    return results;
  })();
  return {
    jitter: jit,
    y: yout
  };
};
// Generated by CoffeeScript 1.10.0
var chrheatmap;

chrheatmap = function() {
  var axispos, bordercolor, cellSelect, celltip, chart, chrGap, colors, hover, margin, nullcolor, oneAtTop, pixelPerCell, rectcolor, rotate_ylab, svg, tipclass, title, titlepos, xlab, ylab, zlim, zscale, zthresh;
  pixelPerCell = 3;
  chrGap = 4;
  margin = {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40
  };
  axispos = {
    xtitle: 25,
    ytitle: 30,
    xlabel: 5,
    ylabel: 5
  };
  titlepos = 20;
  rectcolor = "#e6e6e6";
  nullcolor = "#e6e6e6";
  bordercolor = "black";
  colors = ["slateblue", "white", "crimson"];
  title = "";
  xlab = "";
  ylab = "";
  rotate_ylab = null;
  zlim = null;
  zthresh = null;
  zscale = d3.scale.linear();
  oneAtTop = false;
  hover = true;
  cellSelect = null;
  svg = null;
  celltip = null;
  tipclass = "";
  chart = function(selection) {
    return selection.each(function(data) {
      var cell, cells, chrborders, cur, g, gEnter, height, i, j, k, l, len, nchr, nm, nx, ny, ref, ref1, titlegrp, totmar, val, width, x, xCellStart, xChrBorder, xaxis, yCellStart, yChrBorder, yaxis, zmax, zmin;
      ny = data.z.length;
      nx = (function() {
        var k, len, ref, results;
        ref = data.z;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          x = ref[k];
          results.push(x.length);
        }
        return results;
      })();
      for (i in nx) {
        if (nx[i] !== ny) {
          displayError("Row " + (i + 1) + " of data.z is not the right length: " + nx[i] + " != " + ny);
        }
      }
      nchr = data.nmar.length;
      totmar = sumArray(data.nmar);
      if (totmar !== ny) {
        displayError("sum(data.nmar) [" + (sumArray(data.nmar)) + "] != data.z.length [" + data.z.length + "]");
      }
      if (data.chrnames.length !== nchr) {
        displayError.log("data.nmar.length [" + data.nmar.length + "] != data.chrnames.length [" + data.chrnames.length + "]");
      }
      if (data.labels.length !== totmar) {
        displayError("data.labels.length [" + data.labels.length + "] != sum(data.nmar) [" + (sum(data.nmar)) + "]");
      }
      if (chrGap < 1) {
        displayError("chrGap should be >= 2 (was " + chrGap + ")");
        chrGap = 2;
      }
      xChrBorder = [0];
      xCellStart = [];
      cur = chrGap / 2;
      ref = data.nmar;
      for (k = 0, len = ref.length; k < len; k++) {
        nm = ref[k];
        for (j = l = 0, ref1 = nm; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
          xCellStart.push(cur + 1);
          cur = cur + pixelPerCell;
        }
        xChrBorder.push(cur + 1 + chrGap / 2);
        cur = cur + chrGap;
      }
      width = cur - chrGap / 2;
      height = width;
      if (oneAtTop) {
        yChrBorder = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = xChrBorder.length; m < len1; m++) {
            val = xChrBorder[m];
            results.push(val);
          }
          return results;
        })();
        yCellStart = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = xCellStart.length; m < len1; m++) {
            val = xCellStart[m];
            results.push(val);
          }
          return results;
        })();
      } else {
        yChrBorder = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = xChrBorder.length; m < len1; m++) {
            val = xChrBorder[m];
            results.push(height - val + 1);
          }
          return results;
        })();
        yCellStart = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = xCellStart.length; m < len1; m++) {
            val = xCellStart[m];
            results.push(height - val - pixelPerCell);
          }
          return results;
        })();
      }
      data.cells = [];
      for (i in data.z) {
        for (j in data.z[i]) {
          data.cells.push({
            i: i,
            j: j,
            z: data.z[i][j],
            x: xCellStart[i] + margin.left,
            y: yCellStart[j] + margin.top
          });
        }
      }
      data.allz = (function() {
        var len1, m, ref2, results;
        ref2 = data.cells;
        results = [];
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          cell = ref2[m];
          results.push(cell.z);
        }
        return results;
      })();
      zmin = d3.min(data.allz);
      zmax = d3.max(data.allz);
      if (-zmin > zmax) {
        zmax = -zmin;
      }
      zlim = zlim != null ? zlim : [-zmax, 0, zmax];
      if (zlim.length !== colors.length) {
        displayError("zlim.length (" + zlim.length + ") != colors.length (" + colors.length + ")");
      }
      zscale.domain(zlim).range(colors);
      zthresh = zthresh != null ? zthresh : zmin - 1;
      data.cells = (function() {
        var len1, m, ref2, results;
        ref2 = data.cells;
        results = [];
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          cell = ref2[m];
          if (cell.z >= zthresh || cell.z <= -zthresh) {
            results.push(cell);
          }
        }
        return results;
      })();
      svg = d3.select(this).selectAll("svg").data([data]);
      gEnter = svg.enter().append("svg").attr("class", "d3panels").append("g");
      svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
      g = svg.select("g");
      g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", rectcolor).attr("stroke", null).attr("stroke-width", "0");
      chrborders = g.append("g").attr("id", "chrBorders");
      chrborders.selectAll("empty").data(xChrBorder).enter().append("line").attr("x1", function(d) {
        return d + margin.left;
      }).attr("x2", function(d) {
        return d + margin.left;
      }).attr("y1", margin.top).attr("y2", margin.top + height).attr("stroke", bordercolor).attr("stroke-width", "1");
      chrborders.selectAll("empty").data(yChrBorder).enter().append("line").attr("y1", function(d) {
        return d + margin.top;
      }).attr("y2", function(d) {
        return d + margin.top;
      }).attr("x1", margin.left).attr("x2", margin.left + width).attr("stroke", bordercolor).attr("stroke-width", "1");
      titlegrp = g.append("g").attr("class", "title").append("text").attr("x", margin.left + width / 2).attr("y", margin.top - titlepos).text(title);
      xaxis = g.append("g").attr("class", "x axis");
      xaxis.append("text").attr("class", "title").attr("x", margin.left + width / 2).attr("y", margin.top + height + axispos.xtitle).text(xlab);
      xaxis.selectAll("empty").data(data.chrnames).enter().append("text").attr("x", function(d, i) {
        return margin.left + (xChrBorder[i] + xChrBorder[i + 1]) / 2;
      }).attr("y", oneAtTop ? margin.top - 2 * axispos.xlabel : margin.top + height + axispos.xlabel).text(function(d) {
        return d;
      }).style("dominant-baseline", oneAtTop ? "middle" : "hanging");
      rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
      yaxis = g.append("g").attr("class", "y axis");
      yaxis.append("text").attr("class", "title").attr("y", margin.top + height / 2).attr("x", margin.left - axispos.ytitle).text(ylab).attr("transform", rotate_ylab ? "rotate(270," + (margin.left - axispos.ytitle) + "," + (margin.top + height / 2) + ")" : "");
      yaxis.selectAll("empty").data(data.chrnames).enter().append("text").attr("y", function(d, i) {
        return margin.top + (yChrBorder[i] + yChrBorder[i + 1]) / 2;
      }).attr("x", margin.left - axispos.ylabel).text(function(d) {
        return d;
      });
      celltip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
        return data.labels[d.i] + ", " + data.labels[d.j] + " &rarr; " + (formatAxis(data.allz)(d.z));
      }).direction('e').offset([0, 10]);
      svg.call(celltip);
      cells = g.append("g").attr("id", "cells");
      cellSelect = cells.selectAll("empty").data(data.cells).enter().append("rect").attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", pixelPerCell).attr("height", pixelPerCell).attr("class", function(d, i) {
        return "cell" + i;
      }).attr("fill", function(d) {
        if (d.z != null) {
          return zscale(d.z);
        } else {
          return nullcolor;
        }
      }).attr("stroke", "none").attr("stroke-width", "1").on("mouseover.paneltip", function(d) {
        d3.select(this).attr("stroke", "black");
        if (hover) {
          return celltip.show(d);
        }
      }).on("mouseout.paneltip", function() {
        d3.select(this).attr("stroke", "none");
        if (hover) {
          return celltip.hide();
        }
      });
      return g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", "none").attr("stroke", "black").attr("stroke-width", "none");
    });
  };
  chart.pixelPerCell = function(value) {
    if (!arguments.length) {
      return pixelPerCell;
    }
    pixelPerCell = value;
    return chart;
  };
  chart.chrGap = function(value) {
    if (!arguments.length) {
      return chrGap;
    }
    chrGap = value;
    return chart;
  };
  chart.margin = function(value) {
    if (!arguments.length) {
      return margin;
    }
    margin = value;
    return chart;
  };
  chart.axispos = function(value) {
    if (!arguments.length) {
      return axispos;
    }
    axispos = value;
    return chart;
  };
  chart.titlepos = function(value) {
    if (!arguments.length) {
      return titlepos;
    }
    titlepos = value;
    return chart;
  };
  chart.rectcolor = function(value) {
    if (!arguments.length) {
      return rectcolor;
    }
    rectcolor = value;
    return chart;
  };
  chart.nullcolor = function(value) {
    if (!arguments.length) {
      return nullcolor;
    }
    nullcolor = value;
    return chart;
  };
  chart.bordercolor = function(value) {
    if (!arguments.length) {
      return bordercolor;
    }
    bordercolor = value;
    return chart;
  };
  chart.colors = function(value) {
    if (!arguments.length) {
      return colors;
    }
    colors = value;
    return chart;
  };
  chart.title = function(value) {
    if (!arguments.length) {
      return title;
    }
    title = value;
    return chart;
  };
  chart.xlab = function(value) {
    if (!arguments.length) {
      return xlab;
    }
    xlab = value;
    return chart;
  };
  chart.ylab = function(value) {
    if (!arguments.length) {
      return ylab;
    }
    ylab = value;
    return chart;
  };
  chart.rotate_ylab = function(value) {
    if (!arguments.length) {
      return rotate_ylab;
    }
    rotate_ylab = value;
    return chart;
  };
  chart.zthresh = function(value) {
    if (!arguments.length) {
      return zthresh;
    }
    zthresh = value;
    return chart;
  };
  chart.zlim = function(value) {
    if (!arguments.length) {
      return zlim;
    }
    zlim = value;
    return chart;
  };
  chart.oneAtTop = function(value) {
    if (!arguments.length) {
      return oneAtTop;
    }
    oneAtTop = value;
    return chart;
  };
  chart.hover = function(value) {
    if (!arguments.length) {
      return hover;
    }
    hover = value;
    return chart;
  };
  chart.tipclass = function(value) {
    if (!arguments.length) {
      return tipclass;
    }
    tipclass = value;
    return chart;
  };
  chart.zscale = function() {
    return zscale;
  };
  chart.cellSelect = function() {
    return cellSelect;
  };
  chart.remove = function() {
    svg.remove();
    celltip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var panelframe;

panelframe = function(chartOpts) {
  var axispos, boxcolor, boxwidth, chart, height, margin, nxticks, nyticks, plot_height, plot_width, rectcolor, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rotate_ylab, svg, title, titlepos, v_over_h, width, xNA, xNA_size, xlab, xlabels, xlim, xlineOpts, xlines, xscale, xscale_wnull, xticklab, xticks, yNA, yNA_size, ylab, ylabels, ylim, ylineOpts, ylines, yscale, yscale_wnull, yticklab, yticks;
  if (chartOpts == null) {
    chartOpts = {};
  }
  width = (ref = chartOpts != null ? chartOpts.width : void 0) != null ? ref : 800;
  height = (ref1 = chartOpts != null ? chartOpts.height : void 0) != null ? ref1 : 500;
  margin = (ref2 = chartOpts != null ? chartOpts.margin : void 0) != null ? ref2 : {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40,
    inner: 3
  };
  axispos = (ref3 = chartOpts != null ? chartOpts.axispos : void 0) != null ? ref3 : {
    xtitle: 25,
    ytitle: 45,
    xlabel: 5,
    ylabel: 5
  };
  titlepos = (ref4 = chartOpts != null ? chartOpts.titlepos : void 0) != null ? ref4 : 20;
  title = (ref5 = chartOpts != null ? chartOpts.title : void 0) != null ? ref5 : "";
  xlab = (ref6 = chartOpts != null ? chartOpts.xlab : void 0) != null ? ref6 : "X";
  ylab = (ref7 = chartOpts != null ? chartOpts.ylab : void 0) != null ? ref7 : "Y";
  rotate_ylab = (ref8 = chartOpts != null ? chartOpts.rotate_ylab : void 0) != null ? ref8 : null;
  xNA = (ref9 = chartOpts != null ? chartOpts.xNA : void 0) != null ? ref9 : false;
  yNA = (ref10 = chartOpts != null ? chartOpts.yNA : void 0) != null ? ref10 : false;
  xNA_size = (ref11 = chartOpts != null ? chartOpts.xNA_size : void 0) != null ? ref11 : {
    width: 20,
    gap: 10
  };
  yNA_size = (ref12 = chartOpts != null ? chartOpts.yNA_size : void 0) != null ? ref12 : {
    width: 20,
    gap: 10
  };
  xlim = (ref13 = chartOpts != null ? chartOpts.xlim : void 0) != null ? ref13 : [0, 1];
  ylim = (ref14 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref14 : [0, 1];
  nxticks = (ref15 = chartOpts != null ? chartOpts.nxticks : void 0) != null ? ref15 : 5;
  xticks = (ref16 = chartOpts != null ? chartOpts.xticks : void 0) != null ? ref16 : null;
  xticklab = (ref17 = chartOpts != null ? chartOpts.xticklab : void 0) != null ? ref17 : null;
  nyticks = (ref18 = chartOpts != null ? chartOpts.nyticks : void 0) != null ? ref18 : 5;
  yticks = (ref19 = chartOpts != null ? chartOpts.yticks : void 0) != null ? ref19 : null;
  yticklab = (ref20 = chartOpts != null ? chartOpts.yticklab : void 0) != null ? ref20 : null;
  rectcolor = (ref21 = chartOpts != null ? chartOpts.rectcolor : void 0) != null ? ref21 : "#e6e6e6";
  boxcolor = (ref22 = chartOpts != null ? chartOpts.boxcolor : void 0) != null ? ref22 : "black";
  boxwidth = (ref23 = chartOpts != null ? chartOpts.boxwidth : void 0) != null ? ref23 : 1;
  xlineOpts = (ref24 = chartOpts != null ? chartOpts.xlineOpts : void 0) != null ? ref24 : {
    color: "white",
    width: 2
  };
  ylineOpts = (ref25 = chartOpts != null ? chartOpts.ylineOpts : void 0) != null ? ref25 : {
    color: "white",
    width: 2
  };
  v_over_h = (ref26 = chartOpts != null ? chartOpts.v_over_h : void 0) != null ? ref26 : false;
  yscale = null;
  xscale = null;
  xscale_wnull = null;
  yscale_wnull = null;
  xlines = null;
  ylines = null;
  xlabels = null;
  ylabels = null;
  plot_width = null;
  plot_height = null;
  svg = null;
  chart = function(selection) {
    var boxes, d, g, i, inner_height, inner_width, results, xNA_xpos, xaxis, xrange, yNA_ypos, yaxis, ylabpos_x, ylabpos_y, yrange;
    svg = selection.append("svg");
    svg.attr("width", width).attr("height", height).attr("class", "d3panels");
    g = svg.append("g").attr("id", "frame");
    if (!xNA) {
      xNA_size = {
        width: 0,
        gap: 0
      };
    }
    if (!yNA) {
      yNA_size = {
        width: 0,
        gap: 0
      };
    }
    plot_width = width - (margin.left + margin.right);
    plot_height = height - (margin.top + margin.bottom);
    inner_width = width - (margin.right + margin.left + xNA_size.width + xNA_size.gap);
    inner_height = height - (margin.top + margin.bottom + yNA_size.width + yNA_size.gap);
    boxes = {
      left: [margin.left + xNA_size.width + xNA_size.gap, margin.left, margin.left, margin.left + xNA_size.width + xNA_size.gap],
      width: [inner_width, xNA_size.width, xNA_size.width, inner_width],
      top: [margin.top, margin.top, height - (margin.bottom + yNA_size.width), height - (margin.bottom + yNA_size.width)],
      height: [inner_height, inner_height, yNA_size.width, yNA_size.width]
    };
    xNA_xpos = xNA ? margin.left + xNA_size.width / 2 : -50000;
    yNA_ypos = yNA ? height - margin.bottom - yNA_size.width / 2 : -50000;
    xrange = [boxes.left[0], boxes.left[0] + boxes.width[0]];
    yrange = [boxes.top[0] + boxes.height[0], boxes.top[0]];
    for (i in boxes.left) {
      if (boxes.width[i] > 0 && boxes.height[i] > 0) {
        g.append("rect").attr("x", boxes.left[i]).attr("y", boxes.top[i]).attr("height", boxes.height[i]).attr("width", boxes.width[i]).attr("fill", rectcolor).attr("stroke", "none");
      }
    }
    g.append("g").attr("class", "title").append("text").text(title).attr("x", (width - margin.left - margin.right) / 2 + margin.left).attr("y", titlepos);
    rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
    if (v_over_h) {
      yaxis = g.append("g").attr("class", "y axis");
      xaxis = g.append("g").attr("class", "x axis");
    } else {
      xaxis = g.append("g").attr("class", "x axis");
      yaxis = g.append("g").attr("class", "y axis");
    }
    xaxis.append("text").attr("class", "title").text(xlab).attr("x", (width - margin.left - margin.right) / 2 + margin.left).attr("y", plot_height + margin.top + axispos.xtitle);
    ylabpos_y = (height - margin.top - margin.bottom) / 2 + margin.top;
    ylabpos_x = margin.left - axispos.ytitle;
    yaxis.append("text").attr("class", "title").text(ylab).attr("y", ylabpos_y).attr("x", ylabpos_x).attr("transform", rotate_ylab ? "rotate(270," + ylabpos_x + "," + ylabpos_y + ")" : "");
    xscale = d3.scale.linear().domain(xlim).range([xrange[0] + margin.inner, xrange[1] - margin.inner]);
    yscale = d3.scale.linear().domain(ylim).range([yrange[0] - margin.inner, yrange[1] + margin.inner]);
    xscale_wnull = function(val) {
      if (val == null) {
        return xNA_xpos;
      }
      return xscale(val);
    };
    yscale_wnull = function(val) {
      if (val == null) {
        return yNA_ypos;
      }
      return yscale(val);
    };
    xticks = xticks != null ? xticks : xscale.ticks(nxticks);
    if ((xticklab != null) && xticklab.length !== xticks.length) {
      displayError("xticklab.length (" + xticklab.length + ") != xticks.length (" + xticks.length + ")");
    }
    if (!((xticklab != null) && xticklab.length === xticks.length)) {
      xticklab = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = xticks.length; j < len; j++) {
          d = xticks[j];
          results.push(formatAxis(xticks)(d));
        }
        return results;
      })();
    }
    xticks = [null].concat(xticks);
    xticklab = ["NA"].concat(xticklab);
    yticks = yticks != null ? yticks : yscale.ticks(nyticks);
    if ((yticklab != null) && yticklab.length !== yticks.length) {
      displayError("yticklab.length (" + yticklab.length + ") != yticks.length (" + yticks.length + ")");
    }
    if (!((yticklab != null) && yticklab.length === yticks.length)) {
      yticklab = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = yticks.length; j < len; j++) {
          d = yticks[j];
          results.push(formatAxis(yticks)(d));
        }
        return results;
      })();
    }
    yticks = [null].concat(yticks);
    yticklab = ["NA"].concat(yticklab);
    ylines = yaxis.append("g").attr("id", "ylines").selectAll("empty").data(yticks.concat(yticks)).enter().append("line").attr("y1", function(d) {
      return yscale_wnull(d);
    }).attr("y2", function(d) {
      return yscale_wnull(d);
    }).attr("x1", function(d, i) {
      if (i < yticks.length) {
        return xrange[0];
      }
      return margin.left;
    }).attr("x2", function(d, i) {
      if (i < yticks.length) {
        return xrange[1];
      }
      return margin.left + xNA_size.width;
    }).attr("fill", "none").attr("stroke", ylineOpts.color).attr("stroke-width", ylineOpts.width).attr("shape-rendering", "crispEdges").style("pointer-events", "none");
    xlines = xaxis.append("g").attr("id", "xlines").selectAll("empty").data(xticks.concat(xticks)).enter().append("line").attr("x1", function(d) {
      return xscale_wnull(d);
    }).attr("x2", function(d) {
      return xscale_wnull(d);
    }).attr("y1", function(d, i) {
      if (i < xticks.length) {
        return yrange[0];
      }
      return height - margin.bottom;
    }).attr("y2", function(d, i) {
      if (i < xticks.length) {
        return yrange[1];
      }
      return height - margin.bottom - yNA_size.width;
    }).attr("fill", "none").attr("stroke", xlineOpts.color).attr("stroke-width", xlineOpts.width).attr("shape-rendering", "crispEdges").style("pointer-events", "none");
    xlabels = xaxis.append("g").attr("id", "xlabels").selectAll("empty").data(xticklab).enter().append("text").attr("x", function(d, i) {
      return xscale_wnull(xticks[i]);
    }).attr("y", height - margin.bottom + axispos.xlabel).text(function(d) {
      return d;
    });
    ylabels = yaxis.append("g").attr("id", "ylabels").selectAll("empty").data(yticklab).enter().append("text").attr("y", function(d, i) {
      return yscale_wnull(yticks[i]);
    }).attr("x", margin.left - axispos.ylabel).text(function(d) {
      return d;
    });
    results = [];
    for (i in boxes.left) {
      if (boxes.width[i] > 0 && boxes.height[i] > 0) {
        results.push(g.append("rect").attr("x", boxes.left[i]).attr("y", boxes.top[i]).attr("height", boxes.height[i]).attr("width", boxes.width[i]).attr("fill", "none").attr("stroke", boxcolor).attr("stroke-width", boxwidth).attr("shape-rendering", "crispEdges"));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  chart.xscale = function() {
    return xscale_wnull;
  };
  chart.yscale = function() {
    return yscale_wnull;
  };
  chart.xlines = function() {
    return xlines;
  };
  chart.ylines = function() {
    return ylines;
  };
  chart.xlabels = function() {
    return xlabels;
  };
  chart.ylabels = function() {
    return ylabels;
  };
  chart.svg = function() {
    return svg;
  };
  chart.plot_width = function() {
    return plot_width;
  };
  chart.plot_height = function() {
    return plot_height;
  };
  chart.remove = function() {
    svg.remove();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var lodpanelframe;

lodpanelframe = function(chartOpts) {
  var altrectcolor, axispos, boxcolor, boxwidth, chart, chrSelect, gap, height, margin, nyticks, rectcolor, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rotate_ylab, svg, title, titlepos, width, xlab, xscale, ylab, ylim, ylineOpts, yscale, yticklab, yticks;
  if (chartOpts == null) {
    chartOpts = {};
  }
  width = (ref = chartOpts != null ? chartOpts.width : void 0) != null ? ref : 800;
  height = (ref1 = chartOpts != null ? chartOpts.height : void 0) != null ? ref1 : 500;
  margin = (ref2 = chartOpts != null ? chartOpts.margin : void 0) != null ? ref2 : {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40
  };
  axispos = (ref3 = chartOpts != null ? chartOpts.axispos : void 0) != null ? ref3 : {
    xtitle: 25,
    ytitle: 45,
    xlabel: 5,
    ylabel: 5
  };
  titlepos = (ref4 = chartOpts != null ? chartOpts.titlepos : void 0) != null ? ref4 : 20;
  title = (ref5 = chartOpts != null ? chartOpts.title : void 0) != null ? ref5 : "";
  xlab = (ref6 = chartOpts != null ? chartOpts.xlab : void 0) != null ? ref6 : "Chromosome";
  ylab = (ref7 = chartOpts != null ? chartOpts.ylab : void 0) != null ? ref7 : "LOD score";
  rotate_ylab = (ref8 = chartOpts != null ? chartOpts.rotate_ylab : void 0) != null ? ref8 : null;
  ylim = (ref9 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref9 : [0, 1];
  nyticks = (ref10 = chartOpts != null ? chartOpts.nyticks : void 0) != null ? ref10 : 5;
  yticks = (ref11 = chartOpts != null ? chartOpts.yticks : void 0) != null ? ref11 : null;
  yticklab = (ref12 = chartOpts != null ? chartOpts.yticklab : void 0) != null ? ref12 : null;
  rectcolor = (ref13 = chartOpts != null ? chartOpts.rectcolor : void 0) != null ? ref13 : "#e6e6e6";
  altrectcolor = (ref14 = chartOpts != null ? chartOpts.altrectcolor : void 0) != null ? ref14 : "#d4d4d4";
  boxcolor = (ref15 = chartOpts != null ? chartOpts.boxcolor : void 0) != null ? ref15 : "black";
  boxwidth = (ref16 = chartOpts != null ? chartOpts.boxwidth : void 0) != null ? ref16 : 1;
  ylineOpts = (ref17 = chartOpts != null ? chartOpts.ylineOpts : void 0) != null ? ref17 : {
    color: "white",
    width: 2
  };
  gap = (ref18 = chartOpts != null ? chartOpts.gap : void 0) != null ? ref18 : 5;
  svg = null;
  xscale = null;
  yscale = null;
  chrSelect = null;
  chart = function(selection, data) {
    var c, d, g, plot_height, plot_width, xaxis, xlabels, yaxis, ylabels, ylabpos_x, ylabpos_y, ylines;
    svg = selection.append("svg");
    svg.attr("width", width).attr("height", height).attr("class", "d3panels");
    g = svg.append("g").attr("id", "frame");
    plot_width = width - (margin.left + margin.right);
    plot_height = height - (margin.top + margin.bottom);
    if (!(data != null ? data.start : void 0)) {
      data.start = (function() {
        var j, len, ref19, results;
        ref19 = data.chr;
        results = [];
        for (j = 0, len = ref19.length; j < len; j++) {
          c = ref19[j];
          results.push(0);
        }
        return results;
      })();
    }
    if (data.chr.length !== data.start.length) {
      displayError("data.start.length (" + data.start.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.chr.length !== data.end.length) {
      displayError("data.end.length (" + data.end.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    yscale = d3.scale.linear().domain(ylim).range([plot_height + margin.top, margin.top]);
    xscale = calc_chrscales(plot_width, margin.left, gap, data.chr, data.start, data.end);
    g.append("rect").attr("x", margin.left).attr("width", plot_width).attr("y", margin.top).attr("height", plot_height).attr("fill", rectcolor);
    chrSelect = g.append("g").selectAll("empty").data(data.chr).enter().append("rect").attr("x", function(d, i) {
      return xscale[d](data.start[i]) - gap / 2;
    }).attr("width", function(d, i) {
      return xscale[d](data.end[i]) - xscale[d](data.start[i]) + gap;
    }).attr("y", margin.top).attr("height", plot_height).attr("fill", function(d, i) {
      if (i % 2 === 0) {
        return rectcolor;
      }
      return altrectcolor;
    });
    g.append("g").attr("class", "title").append("text").text(title).attr("x", (width - margin.left - margin.right) / 2 + margin.left).attr("y", titlepos);
    rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
    xaxis = g.append("g").attr("class", "x axis");
    yaxis = g.append("g").attr("class", "y axis");
    xaxis.append("text").attr("class", "title").text(xlab).attr("x", (width - margin.left - margin.right) / 2 + margin.left).attr("y", plot_height + margin.top + axispos.xtitle);
    ylabpos_y = (height - margin.top - margin.bottom) / 2 + margin.top;
    ylabpos_x = margin.left - axispos.ytitle;
    yaxis.append("text").attr("class", "title").text(ylab).attr("y", ylabpos_y).attr("x", ylabpos_x).attr("transform", rotate_ylab ? "rotate(270," + ylabpos_x + "," + ylabpos_y + ")" : "");
    yticks = yticks != null ? yticks : yscale.ticks(nyticks);
    if ((yticklab != null) && yticklab.length !== yticks.length) {
      displayError("yticklab.length (" + yticklab.length + ") != yticks.length (" + yticks.length + ")");
    }
    if (!((yticklab != null) && yticklab.length === yticks.length)) {
      yticklab = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = yticks.length; j < len; j++) {
          d = yticks[j];
          results.push(formatAxis(yticks)(d));
        }
        return results;
      })();
    }
    ylines = yaxis.append("g").attr("id", "ylines").selectAll("empty").data(yticks.concat(yticks)).enter().append("line").attr("y1", function(d) {
      return yscale(d);
    }).attr("y2", function(d) {
      return yscale(d);
    }).attr("x1", function(d, i) {
      return margin.left;
    }).attr("x2", function(d, i) {
      return plot_width + margin.left;
    }).attr("fill", "none").attr("stroke", ylineOpts.color).attr("stroke-width", ylineOpts.width).attr("shape-rendering", "crispEdges").style("pointer-events", "none");
    xlabels = xaxis.append("g").attr("id", "xlabels").selectAll("empty").data(data.chr).enter().append("text").attr("x", function(d, i) {
      return (xscale[d](data.start[i]) + xscale[d](data.end[i])) / 2;
    }).attr("y", height - margin.bottom + axispos.xlabel).text(function(d) {
      return d;
    });
    ylabels = yaxis.append("g").attr("id", "ylabels").selectAll("empty").data(yticklab).enter().append("text").attr("y", function(d, i) {
      return yscale(yticks[i]);
    }).attr("x", margin.left - axispos.ylabel).text(function(d) {
      return d;
    });
    return g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", plot_height).attr("width", plot_width).attr("fill", "none").attr("stroke", boxcolor).attr("stroke-width", boxwidth).attr("shape-rendering", "crispEdges");
  };
  chart.svg = function() {
    return svg;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.chrSelect = function() {
    return chrSelect;
  };
  chart.remove = function() {
    svg.remove();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var cichart;

cichart = function(chartOpts) {
  var chart, horizontal, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, segcolor, segments, segstrokewidth, segwidth, svg, tip, tipclass, v_over_h, vertsegcolor, xcatlabels, xlab, xlineOpts, xscale, ylab, ylim, yscale;
  if (chartOpts == null) {
    chartOpts = {};
  }
  xcatlabels = (ref = chartOpts != null ? chartOpts.xcatlabels : void 0) != null ? ref : null;
  segwidth = (ref1 = chartOpts != null ? chartOpts.segwidth : void 0) != null ? ref1 : 0.4;
  segcolor = (ref2 = chartOpts != null ? chartOpts.segcolor : void 0) != null ? ref2 : "slateblue";
  segstrokewidth = (ref3 = chartOpts != null ? chartOpts.segstrokewidth : void 0) != null ? ref3 : "3";
  vertsegcolor = (ref4 = chartOpts != null ? chartOpts.vertsegcolor : void 0) != null ? ref4 : "slateblue";
  xlab = (ref5 = chartOpts != null ? chartOpts.xlab : void 0) != null ? ref5 : "Group";
  ylab = (ref6 = chartOpts != null ? chartOpts.ylab : void 0) != null ? ref6 : "Response";
  ylim = (ref7 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref7 : null;
  xlineOpts = (ref8 = chartOpts != null ? chartOpts.xlineOpts : void 0) != null ? ref8 : {
    color: "#CDCDCD",
    width: 5
  };
  horizontal = (ref9 = chartOpts != null ? chartOpts.horizontal : void 0) != null ? ref9 : false;
  v_over_h = (ref10 = chartOpts != null ? chartOpts.v_over_h : void 0) != null ? ref10 : horizontal;
  tipclass = (ref11 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref11 : "pointtip";
  xscale = null;
  yscale = null;
  segments = null;
  svg = null;
  tip = null;
  chart = function(selection, data) {
    var high, i, low, mean, myframe, ncat, segmentGroup, xlim, xticks, xval, yval;
    mean = data.mean;
    low = data.low;
    high = data.high;
    ncat = mean.length;
    if (ncat !== low.length) {
      displayError("low.length [" + low.length + "] != mean.length [" + ncat + "]");
    }
    if (ncat !== high.length) {
      displayError("high.length [" + high.length + "] != mean.length [" + ncat + "]");
    }
    xticks = (function() {
      var results;
      results = [];
      for (i in mean) {
        results.push(+i + 1);
      }
      return results;
    })();
    xcatlabels = xcatlabels != null ? xcatlabels : xticks;
    if (xcatlabels.length !== mean.length) {
      displayError("xcatlabels.length [" + xcatlabels.length + "] != mean.length [" + ncat + "]");
    }
    ylim = ylim != null ? ylim : [d3.min(low), d3.max(high)];
    xlim = [0.5, mean.length + 0.5];
    segcolor = expand2vector(forceAsArray(segcolor), mean.length);
    vertsegcolor = expand2vector(forceAsArray(vertsegcolor), mean.length);
    if (horizontal) {
      chartOpts.ylim = xlim.reverse();
      chartOpts.xlim = ylim;
      chartOpts.xlab = ylab;
      chartOpts.ylab = xlab;
      chartOpts.xlineOpts = chartOpts.ylineOpts;
      chartOpts.ylineOpts = xlineOpts;
      chartOpts.yNA = chartOpts.xNA;
      chartOpts.xNA = chartOpts.yNA;
      chartOpts.yticks = xticks;
      chartOpts.yticklab = xcatlabels;
      chartOpts.v_over_h = v_over_h;
    } else {
      chartOpts.ylim = ylim;
      chartOpts.xlim = xlim;
      chartOpts.xlab = xlab;
      chartOpts.ylab = ylab;
      chartOpts.ylineOpts = chartOpts.ylineOpts;
      chartOpts.xlineOpts = xlineOpts;
      chartOpts.xticks = xticks;
      chartOpts.xticklab = xcatlabels;
      chartOpts.v_over_h = v_over_h;
    }
    myframe = panelframe(chartOpts);
    myframe(selection);
    svg = myframe.svg();
    xscale = myframe.xscale();
    yscale = myframe.yscale();
    tip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d, i) {
      var f, index;
      index = i % mean.length;
      f = formatAxis([low[index], mean[index]], 1);
      return (f(mean[index])) + " (" + (f(low[index])) + " - " + (f(high[index])) + ")";
    }).direction('e').offset([0, 10]);
    svg.call(tip);
    segmentGroup = svg.append("g").attr("id", "segments");
    segments = segmentGroup.selectAll("empty").data(low).enter().append("line").attr("x1", function(d, i) {
      if (!horizontal) {
        return xscale(i + 1);
      }
      return xscale(d);
    }).attr("x2", function(d, i) {
      if (!horizontal) {
        return xscale(i + 1);
      }
      return xscale(high[i]);
    }).attr("y1", function(d, i) {
      if (!horizontal) {
        return yscale(d);
      }
      return yscale(i + 1);
    }).attr("y2", function(d, i) {
      if (!horizontal) {
        return yscale(high[i]);
      }
      return yscale(i + 1);
    }).attr("fill", "none").attr("stroke", function(d, i) {
      return vertsegcolor[i];
    }).attr("stroke-width", segstrokewidth).attr("shape-rendering", "crispEdges").on("mouseover.paneltip", tip.show).on("mouseout.paneltip", tip.hide);
    yval = mean.concat(low, high);
    xval = (function() {
      var results;
      results = [];
      for (i in yval) {
        results.push(+(i % ncat) + 1);
      }
      return results;
    })();
    return segments = segmentGroup.selectAll("empty").data(yval).enter().append("line").attr("x1", function(d, i) {
      if (horizontal) {
        return xscale(d);
      } else {
        if (i < ncat) {
          return xscale(xval[i] - segwidth / 2);
        }
        return xscale(xval[i] - segwidth / 3);
      }
    }).attr("x2", function(d, i) {
      if (horizontal) {
        return xscale(d);
      } else {
        if (i < ncat) {
          return xscale(xval[i] + segwidth / 2);
        }
        return xscale(xval[i] + segwidth / 3);
      }
    }).attr("y1", function(d, i) {
      if (horizontal) {
        if (i < ncat) {
          return yscale(xval[i] - segwidth / 2);
        }
        return yscale(xval[i] - segwidth / 3);
      } else {
        return yscale(d);
      }
    }).attr("y2", function(d, i) {
      if (horizontal) {
        if (i < ncat) {
          return yscale(xval[i] + segwidth / 2);
        }
        return yscale(xval[i] + segwidth / 3);
      } else {
        return yscale(d);
      }
    }).attr("fill", "none").attr("stroke", function(d, i) {
      return segcolor[i % mean.length];
    }).attr("stroke-width", segstrokewidth).attr("shape-rendering", "crispEdges").on("mouseover.paneltip", tip.show).on("mouseout.paneltip", tip.hide);
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.segments = function() {
    return segments;
  };
  chart.svg = function() {
    return svg;
  };
  chart.tip = function() {
    return tip;
  };
  chart.remove = function() {
    svg.remove();
    indtip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var crosstab;

crosstab = function(chartOpts) {
  var bordercolor, cellPad, chart, fontsize, height, hilitcolor, margin, rectcolor, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, svg, title, titlepos, width;
  if (chartOpts == null) {
    chartOpts = {};
  }
  width = (ref = chartOpts != null ? chartOpts.width : void 0) != null ? ref : 600;
  height = (ref1 = chartOpts != null ? chartOpts.height : void 0) != null ? ref1 : 300;
  margin = (ref2 = chartOpts != null ? chartOpts.margin : void 0) != null ? ref2 : {
    left: 60,
    top: 80,
    right: 40,
    bottom: 20
  };
  cellPad = (ref3 = chartOpts != null ? chartOpts.cellPad : void 0) != null ? ref3 : null;
  titlepos = (ref4 = chartOpts != null ? chartOpts.titlepos : void 0) != null ? ref4 : 50;
  title = (ref5 = chartOpts != null ? chartOpts.title : void 0) != null ? ref5 : "";
  fontsize = (ref6 = chartOpts != null ? chartOpts.fontsize : void 0) != null ? ref6 : null;
  rectcolor = (ref7 = chartOpts != null ? chartOpts.rectcolor : void 0) != null ? ref7 : "#e6e6e6";
  hilitcolor = (ref8 = chartOpts != null ? chartOpts.hilitcolor : void 0) != null ? ref8 : "#e9cfec";
  bordercolor = (ref9 = chartOpts != null ? chartOpts.bordercolor : void 0) != null ? ref9 : "black";
  svg = null;
  chart = function(selection, data) {
    var borders, cell, cellHeight, cellWidth, cells, collab, colrect, denom, i, j, k, l, m, n, ncol, nrow, o, plot_height, plot_width, rect, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, results, results1, rowlab, rowrect, tab, titles, values, xscale, yscale;
    n = data.x.length;
    if (data.y.length !== n) {
      displayError("data.x.length [" + data.x.length + "] != data.y.length [" + data.y.length + "]");
    }
    data.xcat = (ref10 = data != null ? data.xcat : void 0) != null ? ref10 : unique(x);
    data.ycat = (ref11 = data != null ? data.ycat : void 0) != null ? ref11 : unique(y);
    ncol = data.xcat.length;
    if (d3.max(data.x) >= ncol || d3.min(data.x) < 0) {
      displayError("data.x should be in range 0-" + (ncol - 1) + " [was " + (d3.min(data.x)) + " - " + (d3.max(data.x)) + "]");
    }
    nrow = data.ycat.length;
    if (d3.max(data.y) >= nrow || d3.min(data.y) < 0) {
      displayError("data.y should be in range 0-" + (nrow - 1) + " [was " + (d3.min(data.y)) + " - " + (d3.max(data.y)) + "]");
    }
    tab = calc_crosstab(data);
    data.xlabel = (ref12 = data != null ? data.xlabel : void 0) != null ? ref12 : "";
    data.ylabel = (ref13 = data != null ? data.ylabel : void 0) != null ? ref13 : "";
    cells = [];
    for (i = k = 0, ref14 = nrow; 0 <= ref14 ? k <= ref14 : k >= ref14; i = 0 <= ref14 ? ++k : --k) {
      for (j = l = 0, ref15 = ncol; 0 <= ref15 ? l <= ref15 : l >= ref15; j = 0 <= ref15 ? ++l : --l) {
        cell = {
          value: tab[i][j],
          row: i,
          col: j,
          shaded: false,
          rowpercent: "",
          colpercent: ""
        };
        if (i < nrow - 1 && (j < ncol - 1 || j === ncol)) {
          cell.shaded = true;
        }
        if (j < ncol - 1 && (i < nrow - 1 || i === nrow)) {
          cell.shaded = true;
        }
        if (i < nrow - 1) {
          denom = tab[nrow][j] - tab[nrow - 1][j];
          cell.colpercent = denom > 0 ? (Math.round(100 * tab[i][j] / denom)) + "%" : "\u2014";
        } else if (i === nrow - 1) {
          denom = tab[nrow][j];
          cell.colpercent = denom > 0 ? "(" + (Math.round(100 * tab[i][j] / denom)) + "%)" : "\u2014";
        } else {
          cell.colpercent = cell.value;
        }
        if (j < ncol - 1) {
          denom = tab[i][ncol] - tab[i][ncol - 1];
          cell.rowpercent = denom > 0 ? (Math.round(100 * tab[i][j] / denom)) + "%" : "\u2014";
        } else if (j === ncol - 1) {
          denom = tab[i][ncol];
          cell.rowpercent = denom > 0 ? "(" + (Math.round(100 * tab[i][j] / denom)) + "%)" : "\u2014";
        } else {
          cell.rowpercent = cell.value;
        }
        cells.push(cell);
      }
    }
    plot_width = width - margin.left - margin.right;
    plot_height = height - margin.top - margin.bottom;
    cellWidth = width / (ncol + 2);
    cellHeight = height / (nrow + 2);
    fontsize = fontsize != null ? fontsize : cellHeight * 0.5;
    cellPad = cellPad != null ? cellPad : cellWidth * 0.1;
    width = margin.left + margin.right + (ncol + 2) * cellWidth;
    height = margin.top + margin.bottom + (nrow + 2) * cellHeight;
    xscale = d3.scale.ordinal().domain((function() {
      results = [];
      for (var m = 0, ref16 = ncol + 1; 0 <= ref16 ? m <= ref16 : m >= ref16; 0 <= ref16 ? m++ : m--){ results.push(m); }
      return results;
    }).apply(this)).rangeBands([margin.left, width - margin.right], 0, 0);
    yscale = d3.scale.ordinal().domain((function() {
      results1 = [];
      for (var o = 0, ref17 = nrow + 1; 0 <= ref17 ? o <= ref17 : o >= ref17; 0 <= ref17 ? o++ : o--){ results1.push(o); }
      return results1;
    }).apply(this)).rangeBands([margin.top, height - margin.bottom], 0, 0);
    svg = selection.append("svg").attr("width", width).attr("height", height).attr("class", "d3panels");
    rect = svg.append("g").attr("id", "value_rect");
    rect.selectAll("empty").data(cells).enter().append("rect").attr("x", function(d) {
      return xscale(d.col + 1);
    }).attr("y", function(d) {
      return yscale(d.row + 1);
    }).attr("width", cellWidth).attr("height", cellHeight).attr("fill", function(d) {
      if (d.shaded) {
        return rectcolor;
      } else {
        return "none";
      }
    }).attr("stroke", function(d) {
      if (d.shaded) {
        return rectcolor;
      } else {
        return "none";
      }
    }).attr("stroke-width", 0).style("pointer-events", "none").attr("shape-rendering", "crispEdges");
    values = svg.append("g").attr("id", "values");
    values.selectAll("empty").data(cells).enter().append("text").attr("x", function(d) {
      return xscale(d.col + 1) + cellWidth - cellPad;
    }).attr("y", function(d) {
      return yscale(d.row + 1) + cellHeight / 2;
    }).text(function(d) {
      return d.value;
    }).attr("class", function(d) {
      return "crosstab row" + d.row + " col" + d.col;
    }).style("font-size", fontsize).style("pointer-events", "none");
    colrect = svg.append("g").attr("id", "colrect");
    colrect.selectAll("empty").data(data.xcat.concat("Total")).enter().append("rect").attr("x", function(d, i) {
      return xscale(i + 1);
    }).attr("y", yscale(0)).attr("width", cellWidth).attr("height", cellHeight).attr("fill", "white").attr("stroke", "white").attr("shape-rendering", "crispEdges").on("mouseover", function(d, i) {
      d3.select(this).attr("fill", hilitcolor).attr("stroke", hilitcolor);
      return values.selectAll(".col" + i).text(function(d) {
        return d.colpercent;
      });
    }).on("mouseout", function(d, i) {
      d3.select(this).attr("fill", "white").attr("stroke", "white");
      return values.selectAll("text.col" + i).text(function(d) {
        return d.value;
      });
    });
    collab = svg.append("g").attr("id", "collab");
    collab.selectAll("empty").data(data.xcat.concat("Total")).enter().append("text").attr("x", function(d, i) {
      return xscale(i + 1) + cellWidth - cellPad;
    }).attr("y", yscale(0) + cellHeight / 2).text(function(d) {
      return d;
    }).attr("class", "crosstab").style("font-size", fontsize).style("pointer-events", "none");
    rowrect = svg.append("g").attr("id", "rowrect");
    rowrect.selectAll("empty").data(data.ycat.concat("Total")).enter().append("rect").attr("x", xscale(0)).attr("y", function(d, i) {
      return yscale(i + 1);
    }).attr("width", cellWidth).attr("height", cellHeight).attr("fill", "white").attr("stroke", "white").attr("shape-rendering", "crispEdges").on("mouseover", function(d, i) {
      d3.select(this).attr("fill", hilitcolor).attr("stroke", hilitcolor);
      return values.selectAll(".row" + i).text(function(d) {
        return d.rowpercent;
      });
    }).on("mouseout", function(d, i) {
      d3.select(this).attr("fill", "white").attr("stroke", "white");
      return values.selectAll(".row" + i).text(function(d) {
        return d.value;
      });
    });
    rowlab = svg.append("g").attr("id", "rowlab");
    rowlab.selectAll("empty").data(data.ycat.concat("Total")).enter().append("text").attr("x", xscale(0) + cellWidth - cellPad).attr("y", function(d, i) {
      return yscale(i + 1) + cellHeight / 2;
    }).text(function(d) {
      return d;
    }).attr("class", "crosstab").style("font-size", fontsize).style("pointer-events", "none");
    borders = svg.append("g").attr("id", "borders");
    borders.append("rect").attr("x", xscale(1)).attr("y", yscale(1)).attr("width", cellWidth * ncol).attr("height", cellHeight * nrow).attr("fill", "none").attr("stroke", bordercolor).attr("stroke-width", 2).style("pointer-events", "none").attr("shape-rendering", "crispEdges");
    borders.append("rect").attr("x", xscale(ncol + 1)).attr("y", yscale(nrow + 1)).attr("width", cellWidth).attr("height", cellHeight).attr("fill", "none").attr("stroke", bordercolor).attr("stroke-width", 2).style("pointer-events", "none").attr("shape-rendering", "crispEdges");
    titles = svg.append("g").attr("id", "titles");
    titles.append("text").attr("class", "crosstabtitle").attr("x", margin.left + (ncol + 1) * cellWidth / 2).attr("y", margin.top - cellHeight / 2).text(data.xlabel).style("font-size", fontsize).style("font-weight", "bold");
    titles.append("text").attr("class", "crosstab").attr("x", xscale(0) + cellWidth - cellPad).attr("y", yscale(0) + cellHeight / 2).text(data.ylabel).style("font-size", fontsize).style("font-weight", "bold");
    return titles.append("text").attr("class", "crosstabtitle").attr("x", margin.left + (width - margin.left - margin.right) / 2).attr("y", margin.top - titlepos).text(title).style("font-size", fontsize);
  };
  chart.svg = function() {
    return svg;
  };
  chart.remove = function() {
    svg.remove();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var curvechart;

curvechart = function() {
  var axispos, chart, chartOpts, commonX, curvesSelect, height, indtip, margin, nxticks, nyticks, rectcolor, rotate_ylab, strokecolor, strokecolorhilit, strokewidth, strokewidthhilit, svg, tipclass, title, titlepos, width, xlab, xlim, xscale, xticks, ylab, ylim, yscale, yticks;
  if (typeof chartOpts === "undefined" || chartOpts === null) {
    chartOpts = {};
  }
  width = 800;
  height = 500;
  margin = {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40,
    inner: 5
  };
  axispos = {
    xtitle: 25,
    ytitle: 30,
    xlabel: 5,
    ylabel: 5
  };
  titlepos = 20;
  xlim = null;
  ylim = null;
  nxticks = 5;
  xticks = null;
  nyticks = 5;
  yticks = null;
  rectcolor = "#e6e6e6";
  strokecolor = null;
  strokecolorhilit = null;
  strokewidth = 2;
  strokewidthhilit = 2;
  title = "";
  xlab = "X";
  ylab = "Y";
  rotate_ylab = null;
  yscale = d3.scale.linear();
  xscale = d3.scale.linear();
  curvesSelect = null;
  commonX = true;
  svg = null;
  indtip = null;
  tipclass = "";
  chart = function(selection) {
    return selection.each(function(data) {
      var curve, curves, g, gEnter, group, i, indID, ind_data, j, k, l, lastpoint, len, ngroup, points, pointsg, ref, ref1, ref2, ref3, results, titlegrp, tmp, v, xaxis, xrange, xs, yaxis, yrange, ys;
      indID = (ref = data != null ? data.indID : void 0) != null ? ref : null;
      indID = indID != null ? indID : (function() {
        results = [];
        for (var k = 1, ref1 = data.data.length; 1 <= ref1 ? k <= ref1 : k >= ref1; 1 <= ref1 ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
      group = (ref2 = data != null ? data.group : void 0) != null ? ref2 : (function() {
        var results1;
        results1 = [];
        for (i in data.data) {
          results1.push(1);
        }
        return results1;
      })();
      ngroup = d3.max(group);
      group = (function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = group.length; l < len; l++) {
          g = group[l];
          results1.push(g - 1);
        }
        return results1;
      })();
      if (sumArray((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = group.length; l < len; l++) {
          g = group[l];
          results1.push(g < 0 || g > ngroup - 1);
        }
        return results1;
      })()) > 0) {
        displayError("group values out of range");
        console.log("groups:");
        console.log(g);
      }
      strokecolor = strokecolor != null ? strokecolor : selectGroupColors(ngroup, "pastel");
      strokecolor = expand2vector(strokecolor, ngroup);
      strokecolorhilit = strokecolorhilit != null ? strokecolorhilit : selectGroupColors(ngroup, "dark");
      strokecolorhilit = expand2vector(strokecolorhilit, ngroup);
      if (commonX) {
        data = (function() {
          var results1;
          results1 = [];
          for (i in data.data) {
            results1.push({
              x: data.x,
              y: data.data[i]
            });
          }
          return results1;
        })();
      } else {
        data = data.data;
      }
      if (data.length !== group.length) {
        displayError("data.length (" + data.length + ") != group.length (" + group.length + ")");
      }
      if (data.length !== indID.length) {
        displayError("data.length (" + data.length + ") != indID.length (" + indID.length + ")");
      }
      if (sumArray((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = data.length; l < len; l++) {
          ind_data = data[l];
          results1.push(ind_data.x.length !== ind_data.y.length);
        }
        return results1;
      })()) > 0) {
        displayError("At least one curve with x.length != y.length");
      }
      xlim = xlim != null ? xlim : matrixExtent(pullVarAsArray(data, "x"));
      ylim = ylim != null ? ylim : matrixExtent(pullVarAsArray(data, "y"));
      for (i in data) {
        tmp = data[i];
        data[i] = [];
        for (j in tmp.x) {
          if (!((tmp.x[j] == null) || (tmp.y[j] == null))) {
            data[i].push({
              x: tmp.x[j],
              y: tmp.y[j]
            });
          }
        }
      }
      svg = d3.select(this).selectAll("svg").data([data]);
      gEnter = svg.enter().append("svg").attr("class", "d3panels").append("g");
      svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
      g = svg.select("g");
      g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", rectcolor).attr("stroke", "none");
      xrange = [margin.left + margin.inner, margin.left + width - margin.inner];
      yrange = [margin.top + height - margin.inner, margin.top + margin.inner];
      xscale.domain(xlim).range(xrange);
      yscale.domain(ylim).range(yrange);
      xs = d3.scale.linear().domain(xlim).range(xrange);
      ys = d3.scale.linear().domain(ylim).range(yrange);
      yticks = yticks != null ? yticks : ys.ticks(nyticks);
      xticks = xticks != null ? xticks : xs.ticks(nxticks);
      titlegrp = g.append("g").attr("class", "title").append("text").attr("x", margin.left + width / 2).attr("y", margin.top - titlepos).text(title);
      xaxis = g.append("g").attr("class", "x axis");
      xaxis.selectAll("empty").data(xticks).enter().append("line").attr("x1", function(d) {
        return xscale(d);
      }).attr("x2", function(d) {
        return xscale(d);
      }).attr("y1", margin.top).attr("y2", margin.top + height).attr("fill", "none").attr("stroke", "white").attr("stroke-width", 1).style("pointer-events", "none");
      xaxis.selectAll("empty").data(xticks).enter().append("text").attr("x", function(d) {
        return xscale(d);
      }).attr("y", margin.top + height + axispos.xlabel).text(function(d) {
        return formatAxis(xticks)(d);
      });
      xaxis.append("text").attr("class", "title").attr("x", margin.left + width / 2).attr("y", margin.top + height + axispos.xtitle).text(xlab);
      rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
      yaxis = g.append("g").attr("class", "y axis");
      yaxis.selectAll("empty").data(yticks).enter().append("line").attr("y1", function(d) {
        return yscale(d);
      }).attr("y2", function(d) {
        return yscale(d);
      }).attr("x1", margin.left).attr("x2", margin.left + width).attr("fill", "none").attr("stroke", "white").attr("stroke-width", 1).style("pointer-events", "none");
      yaxis.selectAll("empty").data(yticks).enter().append("text").attr("y", function(d) {
        return yscale(d);
      }).attr("x", margin.left - axispos.ylabel).text(function(d) {
        return formatAxis(yticks)(d);
      });
      yaxis.append("text").attr("class", "title").attr("y", margin.top + height / 2).attr("x", margin.left - axispos.ytitle).text(ylab).attr("transform", rotate_ylab ? "rotate(270," + (margin.left - axispos.ytitle) + "," + (margin.top + height / 2) + ")" : "");
      indtip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
        return indID[d];
      }).direction('e').offset([0, 10]);
      svg.call(indtip);
      curve = d3.svg.line().x(function(d) {
        return xscale(d.x);
      }).y(function(d) {
        return yscale(d.y);
      });
      curves = g.append("g").attr("id", "curves");
      curvesSelect = curves.selectAll("empty").data(d3.range(data.length)).enter().append("path").datum(function(d) {
        return data[d];
      }).attr("d", curve).attr("class", function(d, i) {
        return "path" + i;
      }).attr("fill", "none").attr("stroke", function(d, i) {
        return strokecolor[group[i]];
      }).attr("stroke-width", strokewidth).on("mouseover.panel", function(d, i) {
        var circle;
        d3.select(this).attr("stroke", strokecolorhilit[group[i]]).moveToFront();
        circle = d3.select("circle#hiddenpoint" + i);
        return indtip.show(i, circle.node());
      }).on("mouseout.panel", function(d, i) {
        d3.select(this).attr("stroke", strokecolor[group[i]]).moveToBack();
        return indtip.hide();
      });
      lastpoint = (function() {
        var results1;
        results1 = [];
        for (i in data) {
          results1.push({
            x: null,
            y: null
          });
        }
        return results1;
      })();
      for (i in data) {
        ref3 = data[i];
        for (l = 0, len = ref3.length; l < len; l++) {
          v = ref3[l];
          if ((v.x != null) && (v.y != null)) {
            lastpoint[i] = v;
          }
        }
      }
      pointsg = g.append("g").attr("id", "invisiblepoints");
      points = pointsg.selectAll("empty").data(lastpoint).enter().append("circle").attr("id", function(d, i) {
        return "hiddenpoint" + i;
      }).attr("cx", function(d) {
        return xscale(d.x);
      }).attr("cy", function(d) {
        return yscale(d.y);
      }).attr("r", 1).attr("opacity", 0);
      return g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", "none").attr("stroke", "black").attr("stroke-width", "none");
    });
  };
  chart.width = function(value) {
    if (!arguments.length) {
      return width;
    }
    width = value;
    return chart;
  };
  chart.height = function(value) {
    if (!arguments.length) {
      return height;
    }
    height = value;
    return chart;
  };
  chart.margin = function(value) {
    if (!arguments.length) {
      return margin;
    }
    margin = value;
    return chart;
  };
  chart.axispos = function(value) {
    if (!arguments.length) {
      return axispos;
    }
    axispos = value;
    return chart;
  };
  chart.titlepos = function(value) {
    if (!arguments.length) {
      return titlepos;
    }
    titlepos = value;
    return chart;
  };
  chart.xlim = function(value) {
    if (!arguments.length) {
      return xlim;
    }
    xlim = value;
    return chart;
  };
  chart.nxticks = function(value) {
    if (!arguments.length) {
      return nxticks;
    }
    nxticks = value;
    return chart;
  };
  chart.xticks = function(value) {
    if (!arguments.length) {
      return xticks;
    }
    xticks = value;
    return chart;
  };
  chart.ylim = function(value) {
    if (!arguments.length) {
      return ylim;
    }
    ylim = value;
    return chart;
  };
  chart.nyticks = function(value) {
    if (!arguments.length) {
      return nyticks;
    }
    nyticks = value;
    return chart;
  };
  chart.yticks = function(value) {
    if (!arguments.length) {
      return yticks;
    }
    yticks = value;
    return chart;
  };
  chart.rectcolor = function(value) {
    if (!arguments.length) {
      return rectcolor;
    }
    rectcolor = value;
    return chart;
  };
  chart.strokecolor = function(value) {
    if (!arguments.length) {
      return strokecolor;
    }
    strokecolor = value;
    return chart;
  };
  chart.strokecolorhilit = function(value) {
    if (!arguments.length) {
      return strokecolorhilit;
    }
    strokecolorhilit = value;
    return chart;
  };
  chart.strokewidth = function(value) {
    if (!arguments.length) {
      return strokewidth;
    }
    strokewidth = value;
    return chart;
  };
  chart.strokewidthhilit = function(value) {
    if (!arguments.length) {
      return strokewidthhilit;
    }
    strokewidthhilit = value;
    return chart;
  };
  chart.commonX = function(value) {
    if (!arguments.length) {
      return commonX;
    }
    commonX = value;
    return chart;
  };
  chart.title = function(value) {
    if (!arguments.length) {
      return title;
    }
    title = value;
    return chart;
  };
  chart.xlab = function(value) {
    if (!arguments.length) {
      return xlab;
    }
    xlab = value;
    return chart;
  };
  chart.ylab = function(value) {
    if (!arguments.length) {
      return ylab;
    }
    ylab = value;
    return chart;
  };
  chart.rotate_ylab = function(value) {
    if (!arguments.length) {
      return rotate_ylab;
    }
    rotate_ylab = value;
    return chart;
  };
  chart.tipclass = function(value) {
    if (!arguments.length) {
      return tipclass;
    }
    tipclass = value;
    return chart;
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.curvesSelect = function() {
    return curvesSelect;
  };
  chart.remove = function() {
    svg.remove();
    indtip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var dotchart,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

dotchart = function(chartOpts) {
  var chart, horizontal, indtip, pointcolor, points, pointsize, pointstroke, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, svg, tipclass, v_over_h, xNA, xcategories, xcatlabels, xjitter, xlab, xlineOpts, xscale, yNA, ylab, ylim, yscale;
  if (chartOpts == null) {
    chartOpts = {};
  }
  xcategories = (ref = chartOpts != null ? chartOpts.xcategories : void 0) != null ? ref : null;
  xcatlabels = (ref1 = chartOpts != null ? chartOpts.xcatlabels : void 0) != null ? ref1 : null;
  xjitter = (ref2 = chartOpts != null ? chartOpts.xjitter : void 0) != null ? ref2 : "random";
  xNA = (ref3 = chartOpts != null ? chartOpts.xNA : void 0) != null ? ref3 : {
    handle: true,
    force: false
  };
  yNA = (ref4 = chartOpts != null ? chartOpts.yNA : void 0) != null ? ref4 : {
    handle: true,
    force: false
  };
  ylim = (ref5 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref5 : null;
  xlab = (ref6 = chartOpts != null ? chartOpts.xlab : void 0) != null ? ref6 : "Group";
  ylab = (ref7 = chartOpts != null ? chartOpts.ylab : void 0) != null ? ref7 : "Response";
  xlineOpts = (ref8 = chartOpts != null ? chartOpts.xlineOpts : void 0) != null ? ref8 : {
    color: "#cdcdcd",
    width: 5
  };
  pointcolor = (ref9 = chartOpts != null ? chartOpts.pointcolor : void 0) != null ? ref9 : "slateblue";
  pointstroke = (ref10 = chartOpts != null ? chartOpts.pointstroke : void 0) != null ? ref10 : "black";
  pointsize = (ref11 = chartOpts != null ? chartOpts.pointsize : void 0) != null ? ref11 : 3;
  tipclass = (ref12 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref12 : "pointtip";
  horizontal = (ref13 = chartOpts != null ? chartOpts.horizontal : void 0) != null ? ref13 : false;
  v_over_h = (ref14 = chartOpts != null ? chartOpts.v_over_h : void 0) != null ? ref14 : horizontal;
  xscale = null;
  yscale = null;
  points = null;
  svg = null;
  indtip = null;
  chart = function(selection, data) {
    var h, indID, j, jitter, myframe, pointGroup, ref15, ref16, result, results, v, w, x, xlim, xv, y;
    x = data.x;
    y = data.y;
    indID = (ref15 = data != null ? data.indID : void 0) != null ? ref15 : null;
    indID = indID != null ? indID : (function() {
      results = [];
      for (var j = 1, ref16 = x.length; 1 <= ref16 ? j <= ref16 : j >= ref16; 1 <= ref16 ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    if (x.length !== y.length) {
      displayError("length(x) [" + x.length + "] != length(y) [" + y.length + "]");
    }
    if (indID.length !== x.length) {
      displayError("length(indID) [" + indID.length + "] != length(x) [" + x.length + "]");
    }
    xcategories = xcategories != null ? xcategories : unique(x);
    xcatlabels = xcatlabels != null ? xcatlabels : xcategories;
    if (xcatlabels.length !== xcategories.length) {
      displayError("xcatlabels.length [" + xcatlabels.length + "] != xcategories.length [" + xcategories.length + "]");
    }
    if (sumArray((function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = x.length; k < len; k++) {
        xv = x[k];
        results1.push((xv != null) && !(indexOf.call(xcategories, xv) >= 0));
      }
      return results1;
    })()) > 0) {
      displayError("Some x values not in xcategories");
      console.log("xcategories:");
      console.log(xcategories);
      console.log("x:");
      console.log(x);
    }
    ylim = ylim != null ? ylim : d3.extent(y);
    xlim = [d3.min(xcategories) - 0.5, d3.max(xcategories) + 0.5];
    if (x.every(function(v) {
      return (v != null) && !xNA.force;
    })) {
      xNA.handle = false;
    }
    if (y.every(function(v) {
      return (v != null) && !yNA.force;
    })) {
      yNA.handle = false;
    }
    if (horizontal) {
      chartOpts.ylim = xlim.reverse();
      chartOpts.xlim = ylim;
      chartOpts.xlab = ylab;
      chartOpts.ylab = xlab;
      chartOpts.xlineOpts = chartOpts.ylineOpts;
      chartOpts.ylineOpts = xlineOpts;
      chartOpts.yNA = xNA.handle;
      chartOpts.xNA = yNA.handle;
      chartOpts.yticks = xcategories;
      chartOpts.yticklab = xcatlabels;
      chartOpts.v_over_h = v_over_h;
    } else {
      chartOpts.ylim = ylim;
      chartOpts.xlim = xlim;
      chartOpts.xlab = xlab;
      chartOpts.ylab = ylab;
      chartOpts.ylineOpts = chartOpts.ylineOpts;
      chartOpts.xlineOpts = xlineOpts;
      chartOpts.xNA = xNA.handle;
      chartOpts.yNA = yNA.handle;
      chartOpts.xticks = xcategories;
      chartOpts.xticklab = xcatlabels;
      chartOpts.v_over_h = v_over_h;
    }
    myframe = panelframe(chartOpts);
    myframe(selection);
    svg = myframe.svg();
    xscale = myframe.xscale();
    yscale = myframe.yscale();
    if (data.jitter != null) {
      jitter = data.jitter;
    } else if (xjitter === "none") {
      jitter = (function() {
        var k, len, results1;
        results1 = [];
        for (k = 0, len = x.length; k < len; k++) {
          v = x[k];
          results1.push(0);
        }
        return results1;
      })();
    } else if (xjitter === "deterministic") {
      if (horizontal) {
        h = myframe.plot_width();
        w = myframe.plot_height();
      } else {
        h = myframe.plot_height();
        w = myframe.plot_width();
      }
      result = jiggle(x, y, pointsize, h, w);
      y = result.y;
      jitter = result.jitter;
    } else {
      if (xjitter !== "random") {
        displayError('xjitter should be random|deterministic|none; using "random"');
      }
      jitter = (function() {
        var results1;
        results1 = [];
        for (v in x) {
          results1.push((Math.random() - 0.5) * 0.2);
        }
        return results1;
      })();
    }
    if (jitter.length !== x.length) {
      displayError("jitter.length [" + jitter.length + "] != x.length [" + x.length + "]");
    }
    indtip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d, i) {
      return indID[i];
    }).direction(function() {
      if (horizontal) {
        return 'n';
      }
      return 'e';
    }).offset(function() {
      if (horizontal) {
        return [-10 - pointsize, 0];
      }
      return [0, 10 + pointsize];
    });
    svg.call(indtip);
    pointGroup = svg.append("g").attr("id", "points");
    return points = pointGroup.selectAll("empty").data(x).enter().append("circle").attr("cx", function(d, i) {
      if (!horizontal) {
        return xscale(x[i] + jitter[i]);
      }
      return xscale(y[i]);
    }).attr("cy", function(d, i) {
      if (!horizontal) {
        return yscale(y[i]);
      }
      return yscale(x[i] + jitter[i]);
    }).attr("class", function(d, i) {
      return "pt" + i;
    }).attr("r", pointsize).attr("fill", pointcolor).attr("stroke", pointstroke).attr("stroke-width", "1").attr("opacity", function(d, i) {
      var ref17;
      if (((y[i] != null) || yNA.handle) && (x[i] != null) && (ref17 = x[i], indexOf.call(xcategories, ref17) >= 0)) {
        return 1;
      }
      return 0;
    }).on("mouseover.paneltip", indtip.show).on("mouseout.paneltip", indtip.hide);
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.points = function() {
    return points;
  };
  chart.svg = function() {
    return svg;
  };
  chart.indtip = function() {
    return indtip;
  };
  chart.remove = function() {
    svg.remove();
    indtip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var heatmap;

heatmap = function() {
  var axispos, cellSelect, celltip, chart, colors, dataByCell, height, margin, nullcolor, nxticks, nyticks, rectcolor, rotate_ylab, svg, tipclass, title, titlepos, width, xlab, xlim, xscale, xticks, ylab, ylim, yscale, yticks, zlim, zscale, zthresh;
  width = 400;
  height = 500;
  margin = {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40
  };
  axispos = {
    xtitle: 25,
    ytitle: 30,
    xlabel: 5,
    ylabel: 5
  };
  titlepos = 20;
  xlim = null;
  nxticks = 5;
  xticks = null;
  ylim = null;
  nyticks = 5;
  yticks = null;
  rectcolor = "#e6e6e6";
  nullcolor = "#e6e6e6";
  colors = ["slateblue", "white", "crimson"];
  title = "";
  xlab = "X";
  ylab = "Y";
  rotate_ylab = null;
  zlim = null;
  zthresh = null;
  xscale = d3.scale.linear();
  yscale = d3.scale.linear();
  zscale = d3.scale.linear();
  cellSelect = null;
  dataByCell = false;
  svg = null;
  celltip = null;
  tipclass = "";
  chart = function(selection) {
    return selection.each(function(data) {
      var cell, cells, g, gEnter, i, j, k, len, nx, ny, ref, titlegrp, xLR, xaxis, xrange, yLR, yaxis, yrange, zmax, zmin;
      if (dataByCell) {
        data.x = (function() {
          var k, len, ref, results;
          ref = data.cells;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            results.push(cell.x);
          }
          return results;
        })();
        data.y = (function() {
          var k, len, ref, results;
          ref = data.cells;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            results.push(cell.y);
          }
          return results;
        })();
        data.allz = (function() {
          var k, len, ref, results;
          ref = data.cells;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            results.push(cell.z);
          }
          return results;
        })();
      } else {
        nx = data.x.length;
        ny = data.y.length;
        if (nx !== data.z.length) {
          displayError("data.x.length (" + data.x.length + ") != data.z.length (" + data.z.length + ")");
        }
        if (ny !== data.z[0].length) {
          displayError("data.y.length (" + data.y.length + ") != data.z[0].length (" + data.z[0].length + ")");
        }
        data.cells = [];
        for (i in data.z) {
          for (j in data.z[i]) {
            data.cells.push({
              x: data.x[i],
              y: data.y[j],
              z: data.z[i][j],
              i: i,
              j: j
            });
          }
        }
        data.allz = (function() {
          var k, len, ref, results;
          ref = data.cells;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            cell = ref[k];
            results.push(cell.z);
          }
          return results;
        })();
      }
      data.x.sort(function(a, b) {
        return a - b;
      });
      data.y.sort(function(a, b) {
        return a - b;
      });
      xLR = getLeftRight(data.x);
      yLR = getLeftRight(data.y);
      xlim = xlim != null ? xlim : xLR.extent;
      ylim = ylim != null ? ylim : yLR.extent;
      zmin = d3.min(data.allz);
      zmax = d3.max(data.allz);
      if (-zmin > zmax) {
        zmax = -zmin;
      }
      zlim = zlim != null ? zlim : [-zmax, 0, zmax];
      if (zlim.length !== colors.length) {
        displayError("zlim.length (" + zlim.length + ") != colors.length (" + colors.length + ")");
      }
      zscale.domain(zlim).range(colors);
      zthresh = zthresh != null ? zthresh : zmin - 1;
      data.cells = (function() {
        var k, len, ref, results;
        ref = data.cells;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          if (cell.z >= zthresh || cell.z <= -zthresh) {
            results.push(cell);
          }
        }
        return results;
      })();
      ref = data.cells;
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        cell.recLeft = (xLR[cell.x].left + cell.x) / 2;
        cell.recRight = (xLR[cell.x].right + cell.x) / 2;
        cell.recTop = (yLR[cell.y].right + cell.y) / 2;
        cell.recBottom = (yLR[cell.y].left + cell.y) / 2;
      }
      svg = d3.select(this).selectAll("svg").data([data]);
      gEnter = svg.enter().append("svg").attr("class", "d3panels").append("g");
      svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
      g = svg.select("g");
      g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", rectcolor).attr("stroke", "none");
      xrange = [margin.left, margin.left + width];
      xscale.domain(xlim).range(xrange);
      yrange = [margin.top + height, margin.top];
      yscale.domain(ylim).range(yrange);
      xticks = xticks != null ? xticks : xscale.ticks(nxticks);
      yticks = yticks != null ? yticks : yscale.ticks(nyticks);
      titlegrp = g.append("g").attr("class", "title").append("text").attr("x", margin.left + width / 2).attr("y", margin.top - titlepos).text(title);
      xaxis = g.append("g").attr("class", "x axis");
      xaxis.selectAll("empty").data(xticks).enter().append("line").attr("x1", function(d) {
        return xscale(d);
      }).attr("x2", function(d) {
        return xscale(d);
      }).attr("y1", margin.top).attr("y2", margin.top + height).attr("class", "y axis grid");
      xaxis.selectAll("empty").data(xticks).enter().append("text").attr("x", function(d) {
        return xscale(d);
      }).attr("y", margin.top + height + axispos.xlabel).text(function(d) {
        return formatAxis(xticks)(d);
      });
      xaxis.append("text").attr("class", "title").attr("x", margin.left + width / 2).attr("y", margin.top + height + axispos.xtitle).text(xlab);
      rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
      yaxis = g.append("g").attr("class", "y axis");
      yaxis.selectAll("empty").data(yticks).enter().append("line").attr("y1", function(d) {
        return yscale(d);
      }).attr("y2", function(d) {
        return yscale(d);
      }).attr("x1", margin.left).attr("x2", margin.left + width).attr("class", "y axis grid");
      yaxis.selectAll("empty").data(yticks).enter().append("text").attr("y", function(d) {
        return yscale(d);
      }).attr("x", margin.left - axispos.ylabel).text(function(d) {
        return formatAxis(yticks)(d);
      });
      yaxis.append("text").attr("class", "title").attr("y", margin.top + height / 2).attr("x", margin.left - axispos.ytitle).text(ylab).attr("transform", rotate_ylab ? "rotate(270," + (margin.left - axispos.ytitle) + "," + (margin.top + height / 2) + ")" : "");
      celltip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
        var x, y, z;
        x = formatAxis(data.x)(d.x);
        y = formatAxis(data.y)(d.y);
        z = formatAxis(data.allz)(d.z);
        return "(" + x + ", " + y + ") &rarr; " + z;
      }).direction('e').offset([0, 10]);
      svg.call(celltip);
      cells = g.append("g").attr("id", "cells");
      cellSelect = cells.selectAll("empty").data(data.cells).enter().append("rect").attr("x", function(d) {
        return xscale(d.recLeft);
      }).attr("y", function(d) {
        return yscale(d.recTop);
      }).attr("width", function(d) {
        return xscale(d.recRight) - xscale(d.recLeft);
      }).attr("height", function(d) {
        return yscale(d.recBottom) - yscale(d.recTop);
      }).attr("class", function(d, i) {
        return "cell" + i;
      }).attr("fill", function(d) {
        if (d.z != null) {
          return zscale(d.z);
        } else {
          return nullcolor;
        }
      }).attr("stroke", "none").attr("stroke-width", "1").on("mouseover.paneltip", function(d) {
        d3.select(this).attr("stroke", "black");
        return celltip.show(d);
      }).on("mouseout.paneltip", function() {
        d3.select(this).attr("stroke", "none");
        return celltip.hide();
      });
      return g.append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", height).attr("width", width).attr("fill", "none").attr("stroke", "black").attr("stroke-width", "none");
    });
  };
  chart.width = function(value) {
    if (!arguments.length) {
      return width;
    }
    width = value;
    return chart;
  };
  chart.height = function(value) {
    if (!arguments.length) {
      return height;
    }
    height = value;
    return chart;
  };
  chart.margin = function(value) {
    if (!arguments.length) {
      return margin;
    }
    margin = value;
    return chart;
  };
  chart.axispos = function(value) {
    if (!arguments.length) {
      return axispos;
    }
    axispos = value;
    return chart;
  };
  chart.titlepos = function(value) {
    if (!arguments.length) {
      return titlepos;
    }
    titlepos = value;
    return chart;
  };
  chart.xlim = function(value) {
    if (!arguments.length) {
      return xlim;
    }
    xlim = value;
    return chart;
  };
  chart.nxticks = function(value) {
    if (!arguments.length) {
      return nxticks;
    }
    nxticks = value;
    return chart;
  };
  chart.xticks = function(value) {
    if (!arguments.length) {
      return xticks;
    }
    xticks = value;
    return chart;
  };
  chart.ylim = function(value) {
    if (!arguments.length) {
      return ylim;
    }
    ylim = value;
    return chart;
  };
  chart.nyticks = function(value) {
    if (!arguments.length) {
      return nyticks;
    }
    nyticks = value;
    return chart;
  };
  chart.yticks = function(value) {
    if (!arguments.length) {
      return yticks;
    }
    yticks = value;
    return chart;
  };
  chart.rectcolor = function(value) {
    if (!arguments.length) {
      return rectcolor;
    }
    rectcolor = value;
    return chart;
  };
  chart.nullcolor = function(value) {
    if (!arguments.length) {
      return nullcolor;
    }
    nullcolor = value;
    return chart;
  };
  chart.colors = function(value) {
    if (!arguments.length) {
      return colors;
    }
    colors = value;
    return chart;
  };
  chart.dataByCell = function(value) {
    if (!arguments.length) {
      return dataByCell;
    }
    dataByCell = value;
    return chart;
  };
  chart.title = function(value) {
    if (!arguments.length) {
      return title;
    }
    title = value;
    return chart;
  };
  chart.xlab = function(value) {
    if (!arguments.length) {
      return xlab;
    }
    xlab = value;
    return chart;
  };
  chart.ylab = function(value) {
    if (!arguments.length) {
      return ylab;
    }
    ylab = value;
    return chart;
  };
  chart.rotate_ylab = function(value) {
    if (!arguments.length) {
      return rotate_ylab;
    }
    rotate_ylab = value;
    return chart;
  };
  chart.zthresh = function(value) {
    if (!arguments.length) {
      return zthresh;
    }
    zthresh = value;
    return chart;
  };
  chart.zlim = function(value) {
    if (!arguments.length) {
      return zlim;
    }
    zlim = value;
    return chart;
  };
  chart.tipclass = function(value) {
    if (!arguments.length) {
      return tipclass;
    }
    tipclass = value;
    return chart;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.zscale = function() {
    return zscale;
  };
  chart.cellSelect = function() {
    return cellSelect;
  };
  chart.remove = function() {
    svg.remove();
    celltip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var lodchart;

lodchart = function(chartOpts) {
  var chart, chrSelect, linecolor, linewidth, markerSelect, markertip, pointcolor, pointsize, pointstroke, ref, ref1, ref2, ref3, ref4, ref5, ref6, svg, tipclass, xscale, ylabels, ylim, ylines, yscale;
  if (chartOpts == null) {
    chartOpts = {};
  }
  linecolor = (ref = chartOpts != null ? chartOpts.linecolor : void 0) != null ? ref : "darkslateblue";
  linewidth = (ref1 = chartOpts != null ? chartOpts.linewidth : void 0) != null ? ref1 : 2;
  pointcolor = (ref2 = chartOpts != null ? chartOpts.pointcolor : void 0) != null ? ref2 : "#e9cfec";
  pointsize = (ref3 = chartOpts != null ? chartOpts.pointsize : void 0) != null ? ref3 : 0;
  pointstroke = (ref4 = chartOpts != null ? chartOpts.pointstroke : void 0) != null ? ref4 : "black";
  ylim = (ref5 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref5 : null;
  tipclass = (ref6 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref6 : "pointtip";
  yscale = null;
  xscale = null;
  ylines = null;
  ylabels = null;
  chrSelect = null;
  markerSelect = null;
  markertip = null;
  svg = null;
  chart = function(selection, data) {
    var add2chart, c, i, j, k, len, len1, myframe, ref7, ref8, self_chart, these_pos;
    if (data.pos.length !== data.chr.length) {
      displayError("data.pos.length (" + data.pos.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.lod.length !== data.chr.length) {
      displayError("data.lod.length (" + data.lod.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.marker.length !== data.chr.length) {
      displayError("data.marker.length (" + data.lod.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.chrname == null) {
      data.chrname = unique(data.chr);
    }
    if (data.chrstart == null) {
      data.chrstart = [];
      ref7 = data.chrname;
      for (j = 0, len = ref7.length; j < len; j++) {
        c = ref7[j];
        these_pos = (function() {
          var results;
          results = [];
          for (i in data.chr) {
            if (data.chr[i] === c) {
              results.push(data.pos[i]);
            }
          }
          return results;
        })();
        data.chrstart.push(d3.min(these_pos));
      }
    }
    if (data.chrend == null) {
      data.chrend = [];
      ref8 = data.chrname;
      for (k = 0, len1 = ref8.length; k < len1; k++) {
        c = ref8[k];
        these_pos = (function() {
          var results;
          results = [];
          for (i in data.chr) {
            if (data.chr[i] === c) {
              results.push(data.pos[i]);
            }
          }
          return results;
        })();
        data.chrend.push(d3.max(these_pos));
      }
    }
    data = reorgLodData(data);
    chartOpts.ylim = ylim != null ? ylim : [0, d3.max(data.lod) * 1.05];
    myframe = lodpanelframe(chartOpts);
    myframe(selection, {
      chr: data.chrname,
      start: data.chrstart,
      end: data.chrend
    });
    svg = myframe.svg();
    xscale = myframe.xscale();
    yscale = myframe.yscale();
    chrSelect = myframe.chrSelect();
    self_chart = {
      svg: function() {
        return svg;
      },
      xscale: function() {
        return xscale;
      },
      yscale: function() {
        return yscale;
      }
    };
    add2chart = add_lodcurve(chartOpts);
    add2chart(self_chart, data);
    markerSelect = add2chart.markerSelect();
    return markertip = add2chart.markertip();
  };
  chart.svg = function() {
    return svg;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.chrSelect = function() {
    return chrSelect;
  };
  chart.markerSelect = function() {
    return markerSelect;
  };
  chart.markertip = function() {
    return markertip;
  };
  chart.remove = function() {
    svg.remove();
    markertip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var add_lodcurve;

add_lodcurve = function(chartOpts) {
  var chart, linecolor, linedash, linewidth, markerSelect, markertip, pointcolor, pointsize, pointstroke, ref, ref1, ref2, ref3, ref4, ref5, ref6, tipclass;
  if (chartOpts == null) {
    chartOpts = {};
  }
  linecolor = (ref = chartOpts != null ? chartOpts.linecolor : void 0) != null ? ref : "darkslateblue";
  linewidth = (ref1 = chartOpts != null ? chartOpts.linewidth : void 0) != null ? ref1 : 2;
  linedash = (ref2 = chartOpts != null ? chartOpts.linedash : void 0) != null ? ref2 : "";
  pointcolor = (ref3 = chartOpts != null ? chartOpts.pointcolor : void 0) != null ? ref3 : "#e9cfec";
  pointsize = (ref4 = chartOpts != null ? chartOpts.pointsize : void 0) != null ? ref4 : 0;
  pointstroke = (ref5 = chartOpts != null ? chartOpts.pointstroke : void 0) != null ? ref5 : "black";
  tipclass = (ref6 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref6 : "pointtip";
  markerSelect = null;
  markertip = null;
  chart = function(prevchart, data) {
    var bigpointsize, c, chr, curves, hiddenpoints, i, j, k, l, len, len1, len2, lodcurve, markerpoints, ref7, ref8, ref9, svg, these_pos, xscale, yscale;
    if (data.pos.length !== data.chr.length) {
      displayError("data.pos.length (" + data.pos.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.lod.length !== data.chr.length) {
      displayError("data.lod.length (" + data.lod.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.marker.length !== data.chr.length) {
      displayError("data.marker.length (" + data.lod.length + ") != data.chr.length (" + data.chr.length + ")");
    }
    if (data.chrname == null) {
      data.chrname = unique(data.chr);
    }
    if (data.chrstart == null) {
      data.chrstart = [];
      ref7 = data.chrname;
      for (j = 0, len = ref7.length; j < len; j++) {
        c = ref7[j];
        these_pos = (function() {
          var results;
          results = [];
          for (i in data.chr) {
            if (data.chr[i] === c) {
              results.push(data.pos[i]);
            }
          }
          return results;
        })();
        data.chrstart.push(d3.min(these_pos));
      }
    }
    if (data.chrend == null) {
      data.chrend = [];
      ref8 = data.chrname;
      for (k = 0, len1 = ref8.length; k < len1; k++) {
        c = ref8[k];
        these_pos = (function() {
          var results;
          results = [];
          for (i in data.chr) {
            if (data.chr[i] === c) {
              results.push(data.pos[i]);
            }
          }
          return results;
        })();
        data.chrend.push(d3.max(these_pos));
      }
    }
    if (!((data.posByChr != null) && (data.lodByChr != null) && (data.markerinfo != null))) {
      data = reorgLodData(data);
    }
    svg = prevchart.svg();
    xscale = prevchart.xscale();
    yscale = prevchart.yscale();
    lodcurve = function(chr) {
      return d3.svg.line().x(function(d) {
        return xscale[chr](d);
      }).y(function(d, i) {
        return yscale(data.lodByChr[chr][i]);
      });
    };
    if (linewidth > 0) {
      curves = svg.append("g").attr("id", "curves");
      ref9 = data.chrname;
      for (l = 0, len2 = ref9.length; l < len2; l++) {
        chr = ref9[l];
        curves.append("path").datum(data.posByChr[chr]).attr("d", lodcurve(chr)).attr("stroke", linecolor).attr("fill", "none").attr("stroke-width", linewidth).attr("stroke-dasharray", linedash).style("pointer-events", "none");
      }
    }
    if (pointsize > 0) {
      markerpoints = svg.append("g").attr("id", "markerpoints_visible");
      markerpoints.selectAll("empty").data(data.markerinfo).enter().append("circle").attr("cx", function(d) {
        return xscale[d.chr](d.pos);
      }).attr("cy", function(d) {
        return yscale(d.lod);
      }).attr("r", function(d) {
        if (d.lod != null) {
          return pointsize;
        } else {
          return null;
        }
      }).attr("fill", pointcolor).attr("stroke", pointstroke).attr("pointer-events", "hidden");
    }
    hiddenpoints = svg.append("g").attr("id", "markerpoints_hidden");
    markertip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
      return [d.name, " LOD = " + (d3.format('.2f')(d.lod))];
    }).direction("e").offset([0, 10]);
    svg.call(markertip);
    bigpointsize = d3.max([2 * pointsize, 3]);
    return markerSelect = hiddenpoints.selectAll("empty").data(data.markerinfo).enter().append("circle").attr("cx", function(d) {
      return xscale[d.chr](d.pos);
    }).attr("cy", function(d) {
      return yscale(d.lod);
    }).attr("id", function(d) {
      return d.name;
    }).attr("r", function(d) {
      if (d.lod != null) {
        return bigpointsize;
      } else {
        return null;
      }
    }).attr("opacity", 0).attr("fill", pointcolor).attr("stroke", pointstroke).attr("stroke-width", "1").on("mouseover.paneltip", function(d) {
      d3.select(this).attr("opacity", 1);
      return markertip.show(d);
    }).on("mouseout.paneltip", function() {
      return d3.select(this).attr("opacity", 0).call(markertip.hide);
    });
  };
  chart.markerSelect = function() {
    return markerSelect;
  };
  chart.markertip = function() {
    return markertip;
  };
  chart.remove = function() {
    svg.remove();
    markertip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var lodheatmap;

lodheatmap = function() {
  var axispos, cellSelect, celltip, chart, chrGap, colors, height, lod_labels, margin, nullcolor, nyticks, quantScale, rectcolor, rotate_ylab, svg, tipclass, title, titlepos, width, xlab, xscale, ylab, yscale, yticks, zlim, zscale, zthresh;
  width = 1200;
  height = 600;
  margin = {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40
  };
  axispos = {
    xtitle: 25,
    ytitle: 30,
    xlabel: 5,
    ylabel: 5
  };
  chrGap = 8;
  titlepos = 20;
  rectcolor = "#e6e6e6";
  nullcolor = "#e6e6e6";
  colors = ["slateblue", "white", "crimson"];
  title = "";
  xlab = "Chromosome";
  ylab = "";
  rotate_ylab = null;
  zlim = null;
  zthresh = null;
  quantScale = null;
  lod_labels = null;
  nyticks = 5;
  yticks = null;
  xscale = d3.scale.linear();
  yscale = d3.scale.linear();
  zscale = d3.scale.linear();
  cellSelect = null;
  svg = null;
  celltip = null;
  tipclass = "";
  chart = function(selection) {
    return selection.each(function(data) {
      var cells, chr, extent, g, gEnter, i, j, k, l, len, len1, len2, len3, len4, lod, lodcol, m, n, nlod, o, pos, quant_y_scale, rectHeight, ref, ref1, ref2, ref3, ref4, titlegrp, xLR, xaxis, yaxis, zmax, zmin;
      data = reorgLodData(data);
      data = chrscales(data, width, chrGap, margin.left, true);
      xscale = data.xscale;
      nlod = data.lodnames.length;
      yscale.domain([-0.5, nlod - 0.5]).range([margin.top + height, margin.top]);
      rectHeight = yscale(0) - yscale(1);
      xLR = {};
      ref = data.chrnames;
      for (k = 0, len = ref.length; k < len; k++) {
        chr = ref[k];
        xLR[chr] = getLeftRight(data.posByChr[chr]);
      }
      zmin = 0;
      zmax = 0;
      ref1 = data.lodnames;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        lodcol = ref1[l];
        extent = d3.extent(data[lodcol]);
        if (extent[0] < zmin) {
          zmin = extent[0];
        }
        if (extent[1] > zmax) {
          zmax = extent[1];
        }
      }
      if (-zmin > zmax) {
        zmax = -zmin;
      }
      zlim = zlim != null ? zlim : [-zmax, 0, zmax];
      if (zlim.length !== colors.length) {
        displayError("zlim.length (" + zlim.length + ") != colors.length (" + colors.length + ")");
      }
      zscale.domain(zlim).range(colors);
      zthresh = zthresh != null ? zthresh : zmin - 1;
      data.cells = [];
      ref2 = data.chrnames;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        chr = ref2[m];
        ref3 = data.posByChr[chr];
        for (i = n = 0, len3 = ref3.length; n < len3; i = ++n) {
          pos = ref3[i];
          ref4 = data.lodByChr[chr][i];
          for (j = o = 0, len4 = ref4.length; o < len4; j = ++o) {
            lod = ref4[j];
            if (lod >= zthresh || lod <= -zthresh) {
              data.cells.push({
                z: lod,
                left: (xscale[chr](pos) + xscale[chr](xLR[chr][pos].left)) / 2,
                right: (xscale[chr](pos) + xscale[chr](xLR[chr][pos].right)) / 2,
                lodindex: j,
                chr: chr,
                pos: pos
              });
            }
          }
        }
      }
      lod_labels = lod_labels != null ? lod_labels : data.lodnames;
      svg = d3.select(this).selectAll("svg").data([data]);
      gEnter = svg.enter().append("svg").attr("class", "d3panels").append("g");
      svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
      g = svg.select("g");
      g.append("g").attr("id", "boxes").selectAll("empty").data(data.chrnames).enter().append("rect").attr("id", function(d) {
        return "box" + d;
      }).attr("x", function(d, i) {
        return data.chrStart[i];
      }).attr("y", function(d) {
        return margin.top;
      }).attr("height", height).attr("width", function(d, i) {
        return data.chrEnd[i] - data.chrStart[i];
      }).attr("fill", rectcolor).attr("stroke", "none");
      titlegrp = g.append("g").attr("class", "title").append("text").attr("x", margin.left + width / 2).attr("y", margin.top - titlepos).text(title);
      xaxis = g.append("g").attr("class", "x axis");
      xaxis.selectAll("empty").data(data.chrnames).enter().append("text").attr("x", function(d, i) {
        return (data.chrStart[i] + data.chrEnd[i]) / 2;
      }).attr("y", margin.top + height + axispos.xlabel).text(function(d) {
        return d;
      });
      xaxis.append("text").attr("class", "title").attr("x", margin.left + width / 2).attr("y", margin.top + height + axispos.xtitle).text(xlab);
      rotate_ylab = rotate_ylab != null ? rotate_ylab : ylab.length > 1;
      yaxis = g.append("g").attr("class", "y axis");
      yaxis.append("text").attr("class", "title").attr("y", margin.top + height / 2).attr("x", margin.left - axispos.ytitle).text(ylab).attr("transform", rotate_ylab ? "rotate(270," + (margin.left - axispos.ytitle) + "," + (margin.top + height / 2) + ")" : "");
      if (quantScale != null) {
        quant_y_scale = d3.scale.linear().domain([quantScale[0], quantScale[quantScale.length - 1]]).range([margin.top + height - rectHeight / 2, margin.top + rectHeight / 2]);
        yticks = yticks != null ? yticks : quant_y_scale.ticks(nyticks);
        yaxis.selectAll("empty").data(yticks).enter().append("text").attr("y", function(d) {
          return quant_y_scale(d);
        }).attr("x", margin.left - axispos.ylabel).text(function(d) {
          return formatAxis(yticks)(d);
        });
      } else {
        yaxis.selectAll("empty").data(lod_labels).enter().append("text").attr("id", function(d, i) {
          return "yaxis" + i;
        }).attr("y", function(d, i) {
          return yscale(i);
        }).attr("x", margin.left - axispos.ylabel).text(function(d) {
          return d;
        }).attr("opacity", 0);
      }
      celltip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
        var p, z;
        z = d3.format(".2f")(Math.abs(d.z));
        p = d3.format(".1f")(d.pos);
        return d.chr + "@" + p + ", " + lod_labels[d.lodindex] + " &rarr; " + z;
      }).direction('e').offset([0, 10]);
      svg.call(celltip);
      cells = g.append("g").attr("id", "cells");
      cellSelect = cells.selectAll("empty").data(data.cells).enter().append("rect").attr("x", function(d) {
        return d.left;
      }).attr("y", function(d) {
        return yscale(d.lodindex) - rectHeight / 2;
      }).attr("width", function(d) {
        return d.right - d.left;
      }).attr("height", rectHeight).attr("class", function(d, i) {
        return "cell" + i;
      }).attr("fill", function(d) {
        if (d.z != null) {
          return zscale(d.z);
        } else {
          return nullcolor;
        }
      }).attr("stroke", "none").attr("stroke-width", "1").on("mouseover.paneltip", function(d) {
        yaxis.select("text#yaxis" + d.lodindex).attr("opacity", 1);
        d3.select(this).attr("stroke", "black");
        return celltip.show(d);
      }).on("mouseout.paneltip", function(d) {
        yaxis.select("text#yaxis" + d.lodindex).attr("opacity", 0);
        d3.select(this).attr("stroke", "none");
        return celltip.hide();
      });
      return g.append("g").attr("id", "boxes").selectAll("empty").data(data.chrnames).enter().append("rect").attr("id", function(d) {
        return "box" + d;
      }).attr("x", function(d, i) {
        return data.chrStart[i];
      }).attr("y", function(d) {
        return margin.top;
      }).attr("height", height).attr("width", function(d, i) {
        return data.chrEnd[i] - data.chrStart[i];
      }).attr("fill", "none").attr("stroke", "black").attr("stroke-width", "none");
    });
  };
  chart.width = function(value) {
    if (!arguments.length) {
      return width;
    }
    width = value;
    return chart;
  };
  chart.height = function(value) {
    if (!arguments.length) {
      return height;
    }
    height = value;
    return chart;
  };
  chart.margin = function(value) {
    if (!arguments.length) {
      return margin;
    }
    margin = value;
    return chart;
  };
  chart.axispos = function(value) {
    if (!arguments.length) {
      return axispos;
    }
    axispos = value;
    return chart;
  };
  chart.titlepos = function(value) {
    if (!arguments.length) {
      return titlepos;
    }
    titlepos = value;
    return chart;
  };
  chart.rectcolor = function(value) {
    if (!arguments.length) {
      return rectcolor;
    }
    rectcolor = value;
    return chart;
  };
  chart.nullcolor = function(value) {
    if (!arguments.length) {
      return nullcolor;
    }
    nullcolor = value;
    return chart;
  };
  chart.colors = function(value) {
    if (!arguments.length) {
      return colors;
    }
    colors = value;
    return chart;
  };
  chart.title = function(value) {
    if (!arguments.length) {
      return title;
    }
    title = value;
    return chart;
  };
  chart.xlab = function(value) {
    if (!arguments.length) {
      return xlab;
    }
    xlab = value;
    return chart;
  };
  chart.ylab = function(value) {
    if (!arguments.length) {
      return ylab;
    }
    ylab = value;
    return chart;
  };
  chart.rotate_ylab = function(value) {
    if (!arguments.length) {
      return rotate_ylab;
    }
    rotate_ylab = value;
    return chart;
  };
  chart.zthresh = function(value) {
    if (!arguments.length) {
      return zthresh;
    }
    zthresh = value;
    return chart;
  };
  chart.zlim = function(value) {
    if (!arguments.length) {
      return zlim;
    }
    zlim = value;
    return chart;
  };
  chart.chrGap = function(value) {
    if (!arguments.length) {
      return chrGap;
    }
    chrGap = value;
    return chart;
  };
  chart.nyticks = function(value) {
    if (!arguments.length) {
      return nyticks;
    }
    nyticks = value;
    return chart;
  };
  chart.yticks = function(value) {
    if (!arguments.length) {
      return yticks;
    }
    yticks = value;
    return chart;
  };
  chart.quantScale = function(value) {
    if (!arguments.length) {
      return quantScale;
    }
    quantScale = value;
    return chart;
  };
  chart.lod_labels = function(value) {
    if (!arguments.length) {
      return lod_labels;
    }
    lod_labels = value;
    return chart;
  };
  chart.tipclass = function(value) {
    if (!arguments.length) {
      return tipclass;
    }
    tipclass = value;
    return chart;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.zscale = function() {
    return zscale;
  };
  chart.cellSelect = function() {
    return cellSelect;
  };
  chart.remove = function() {
    svg.remove();
    celltip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var mapchart;

mapchart = function(chartOpts) {
  var chart, horizontal, linecolor, linecolorhilit, linewidth, markerSelect, martip, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, shiftStart, svg, tickwidth, tipclass, v_over_h, xlab, xlineOpts, xscale, ylab, yscale;
  if (chartOpts == null) {
    chartOpts = {};
  }
  tickwidth = (ref = chartOpts != null ? chartOpts.tickwidth : void 0) != null ? ref : 10;
  linecolor = (ref1 = chartOpts != null ? chartOpts.linecolor : void 0) != null ? ref1 : "slateblue";
  linecolorhilit = (ref2 = typeof chartopts !== "undefined" && chartopts !== null ? chartopts.linecolorhilit : void 0) != null ? ref2 : "Orchid";
  linewidth = (ref3 = chartOpts != null ? chartOpts.linewidth : void 0) != null ? ref3 : 3;
  xlab = (ref4 = chartOpts != null ? chartOpts.xlab : void 0) != null ? ref4 : "Chromosome";
  ylab = (ref5 = chartOpts != null ? chartOpts.ylab : void 0) != null ? ref5 : "Position (cM)";
  xlineOpts = (ref6 = chartOpts != null ? chartOpts.xlineOpts : void 0) != null ? ref6 : {
    color: "#cdcdcd",
    width: 5
  };
  horizontal = (ref7 = chartOpts != null ? chartOpts.horizontal : void 0) != null ? ref7 : false;
  v_over_h = (ref8 = chartOpts != null ? chartOpts.v_over_h : void 0) != null ? ref8 : horizontal;
  shiftStart = (ref9 = chartOpts != null ? chartOpts.shiftStart : void 0) != null ? ref9 : false;
  tipclass = (ref10 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref10 : "pointtip";
  xscale = null;
  yscale = null;
  markerSelect = null;
  svg = null;
  martip = null;
  chart = function(selection, data) {
    var chr, chrscale, extentByChr, i, j, k, l, len, len1, markerpos, markers, minpos, myframe, n_chr, n_pos, pos, ref11, ref12, these_index, these_pos, x, xlim, xticklab, xticks, ylim;
    n_pos = data.pos.length;
    if (data.chr.length !== n_pos) {
      displayError("data.chr.length (" + data.chr.length + ") != data.pos.length (" + n_pos + ")");
    }
    if (data.marker.length !== n_pos) {
      displayError("data.marker.length (" + data.marker.length + ") != data.pos.length (" + n_pos + ")");
    }
    if (data.chrname == null) {
      data.chrname = unique(data.chr);
    }
    data.adjpos = data.pos.slice(0);
    if (shiftStart) {
      ref11 = data.chrname;
      for (k = 0, len = ref11.length; k < len; k++) {
        chr = ref11[k];
        these_pos = (function() {
          var results;
          results = [];
          for (i in data.pos) {
            if (data.chr[i] === chr) {
              results.push(data.pos[i]);
            }
          }
          return results;
        })();
        these_index = (function() {
          var results;
          results = [];
          for (i in data.pos) {
            if (data.chr[i] === chr) {
              results.push(i);
            }
          }
          return results;
        })();
        minpos = d3.min(these_pos);
        these_pos = (function() {
          var l, len1, results;
          results = [];
          for (l = 0, len1 = these_pos.length; l < len1; l++) {
            x = these_pos[l];
            results.push(x - minpos);
          }
          return results;
        })();
        for (j in these_pos) {
          data.adjpos[these_index[j]] = these_pos[j];
        }
      }
    }
    extentByChr = {};
    ref12 = data.chrname;
    for (l = 0, len1 = ref12.length; l < len1; l++) {
      chr = ref12[l];
      pos = (function() {
        var results;
        results = [];
        for (i in data.adjpos) {
          if (data.chr[i] === chr) {
            results.push(data.adjpos[i]);
          }
        }
        return results;
      })();
      extentByChr[chr] = d3.extent(pos);
    }
    ylim = ylim != null ? ylim : d3.extent(data.adjpos);
    n_chr = data.chrname.length;
    xlim = [0.5, n_chr + 0.5];
    xticks = (function() {
      var len2, m, ref13, results;
      ref13 = d3.range(n_chr);
      results = [];
      for (m = 0, len2 = ref13.length; m < len2; m++) {
        i = ref13[m];
        results.push(i + 1);
      }
      return results;
    })();
    xticklab = data.chrname;
    chartOpts.xNA = false;
    chartOpts.yNA = false;
    if (horizontal) {
      chartOpts.xlim = ylim;
      chartOpts.ylim = xlim.reverse();
      chartOpts.xlineOpts = chartOpts.ylineOpts;
      chartOpts.ylineOpts = xlineOpts;
      chartOpts.xlab = ylab;
      chartOpts.ylab = xlab;
      chartOpts.xticks = chartOpts.yticks;
      chartOpts.yticks = xticks;
      chartOpts.nxticks = chartOpts.nyticks;
      chartOpts.xticklab = chartOpts.yticklab;
      chartOpts.yticklab = xticklab;
      chartOpts.v_over_h = v_over_h;
    } else {
      chartOpts.xlim = xlim;
      chartOpts.ylim = ylim.reverse();
      chartOpts.xlineOpts = xlineOpts;
      chartOpts.xlab = xlab;
      chartOpts.ylab = ylab;
      chartOpts.xticks = xticks;
      chartOpts.xticklab = xticklab;
      chartOpts.v_over_h = v_over_h;
    }
    myframe = panelframe(chartOpts);
    myframe(selection);
    svg = myframe.svg();
    xscale = myframe.xscale();
    yscale = myframe.yscale();
    chrscale = function(chr) {
      var chrpos;
      chrpos = data.chrname.indexOf(chr) + 1;
      if (!horizontal) {
        return xscale(chrpos);
      }
      return yscale(chrpos);
    };
    svg.append("g").attr("id", "chromosomes").selectAll("empty").data(data.chrname).enter().append("line").attr("x1", function(d) {
      if (horizontal) {
        return xscale(extentByChr[d][0]);
      }
      return chrscale(d);
    }).attr("x2", function(d) {
      if (horizontal) {
        return xscale(extentByChr[d][1]);
      }
      return chrscale(d);
    }).attr("y1", function(d) {
      if (horizontal) {
        return chrscale(d);
      }
      return yscale(extentByChr[d][0]);
    }).attr("y2", function(d) {
      if (horizontal) {
        return chrscale(d);
      }
      return yscale(extentByChr[d][1]);
    }).attr("fill", "none").attr("stroke", linecolor).attr("stroke-width", linewidth).attr("shape-rendering", "crispEdges").style("pointer-events", "none");
    markerpos = {};
    for (i in data.marker) {
      markerpos[data.marker[i]] = d3.format(".1f")(data.pos[i]);
    }
    martip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d) {
      return d + " (" + markerpos[d] + ")";
    }).direction(function() {
      if (horizontal) {
        return 'n';
      }
      return 'e';
    }).offset(function() {
      if (horizontal) {
        return [-10, 0];
      }
      return [0, 10];
    });
    svg.call(martip);
    markers = svg.append("g").attr("id", "points");
    return markerSelect = markers.selectAll("empty").data(data.marker).enter().append("line").attr("x1", function(d, i) {
      if (horizontal) {
        return xscale(data.adjpos[i]);
      }
      return chrscale(data.chr[i]) - tickwidth;
    }).attr("x2", function(d, i) {
      if (horizontal) {
        return xscale(data.adjpos[i]);
      }
      return chrscale(data.chr[i]) + tickwidth;
    }).attr("y1", function(d, i) {
      if (horizontal) {
        return chrscale(data.chr[i]) - tickwidth;
      }
      return yscale(data.adjpos[i]);
    }).attr("y2", function(d, i) {
      if (horizontal) {
        return chrscale(data.chr[i]) + tickwidth;
      }
      return yscale(data.adjpos[i]);
    }).attr("id", function(d) {
      return d;
    }).attr("fill", "none").attr("stroke", linecolor).attr("stroke-width", linewidth).attr("shape-rendering", "crispEdges").on("mouseover.paneltip", function(d) {
      d3.select(this).attr("stroke", linecolorhilit);
      return martip.show(d);
    }).on("mouseout.paneltip", function() {
      d3.select(this).attr("stroke", linecolor);
      return martip.hide();
    });
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.markerSelect = function() {
    return markerSelect;
  };
  chart.svg = function() {
    return svg;
  };
  chart.martip = function() {
    return martip;
  };
  chart.remove = function() {
    svg.remove();
    martip.destroy();
    return null;
  };
  return chart;
};
// Generated by CoffeeScript 1.10.0
var scatterplot;

scatterplot = function(chartOpts) {
  var chart, indtip, pointcolor, points, pointsize, pointstroke, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, svg, tipclass, xNA, xlim, xscale, yNA, ylim, yscale;
  if (chartOpts == null) {
    chartOpts = {};
  }
  xNA = (ref = chartOpts != null ? chartOpts.xNA : void 0) != null ? ref : {
    handle: true,
    force: false
  };
  yNA = (ref1 = chartOpts != null ? chartOpts.yNA : void 0) != null ? ref1 : {
    handle: true,
    force: false
  };
  xlim = (ref2 = chartOpts != null ? chartOpts.xlim : void 0) != null ? ref2 : null;
  ylim = (ref3 = chartOpts != null ? chartOpts.ylim : void 0) != null ? ref3 : null;
  pointcolor = (ref4 = chartOpts != null ? chartOpts.pointcolor : void 0) != null ? ref4 : null;
  pointstroke = (ref5 = chartOpts != null ? chartOpts.pointstroke : void 0) != null ? ref5 : "black";
  pointsize = (ref6 = chartOpts != null ? chartOpts.pointsize : void 0) != null ? ref6 : 3;
  tipclass = (ref7 = chartOpts != null ? chartOpts.tipclass : void 0) != null ? ref7 : "pointtip";
  points = null;
  svg = null;
  indtip = null;
  xscale = null;
  yscale = null;
  chart = function(selection, data) {
    var g, group, i, indID, j, myframe, ngroup, pointGroup, ref10, ref8, ref9, results, x, y;
    x = data.x;
    y = data.y;
    if (x.length !== y.length) {
      displayError("x.length (" + x.length + ") != y.length (" + y.length + ")");
    }
    x = missing2null(x, ["NA", ""]);
    y = missing2null(y, ["NA", ""]);
    indID = (ref8 = data != null ? data.indID : void 0) != null ? ref8 : null;
    indID = indID != null ? indID : (function() {
      results = [];
      for (var j = 1, ref9 = x.length; 1 <= ref9 ? j <= ref9 : j >= ref9; 1 <= ref9 ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    if (indID.length !== x.length) {
      displayError("indID.length (" + indID.length + ") != x.length (" + x.length + ")");
    }
    group = (ref10 = data != null ? data.group : void 0) != null ? ref10 : (function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = x.length; k < len; k++) {
        i = x[k];
        results1.push(1);
      }
      return results1;
    })();
    ngroup = d3.max(group);
    group = (function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = group.length; k < len; k++) {
        g = group[k];
        results1.push(g - 1);
      }
      return results1;
    })();
    if (sumArray((function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = group.length; k < len; k++) {
        g = group[k];
        results1.push(g < 0 || g > ngroup - 1);
      }
      return results1;
    })()) > 0) {
      displayError("group values out of range");
      console.log("ngroup: " + ngroup);
      console.log("g:");
      console.log(g);
    }
    if (group.length !== x.length) {
      displayError("group.length (" + group.length + ") != x.length (" + x.length + ")");
    }
    pointcolor = pointcolor != null ? pointcolor : selectGroupColors(ngroup, "dark");
    pointcolor = expand2vector(pointcolor, ngroup);
    if (pointcolor.length !== ngroup) {
      displayError("pointcolor.length (" + pointcolor.length + ") != ngroup (" + ngroup + ")");
    }
    if (x.every(function(v) {
      return (v != null) && !xNA.force;
    })) {
      xNA.handle = false;
    }
    if (y.every(function(v) {
      return (v != null) && !yNA.force;
    })) {
      yNA.handle = false;
    }
    xlim = xlim != null ? xlim : d3.extent(x);
    ylim = ylim != null ? ylim : d3.extent(y);
    chartOpts.xlim = xlim;
    chartOpts.ylim = ylim;
    chartOpts.xNA = xNA.handle;
    chartOpts.yNA = yNA.handle;
    myframe = panelframe(chartOpts);
    myframe(selection);
    svg = myframe.svg();
    xscale = myframe.xscale();
    yscale = myframe.yscale();
    indtip = d3.tip().attr('class', "d3-tip " + tipclass).html(function(d, i) {
      return indID[i];
    }).direction('e').offset([0, 10]);
    svg.call(indtip);
    pointGroup = svg.append("g").attr("id", "points");
    return points = pointGroup.selectAll("empty").data(d3.range(x.length)).enter().append("circle").attr("cx", function(d, i) {
      return xscale(x[i]);
    }).attr("cy", function(d, i) {
      return yscale(y[i]);
    }).attr("class", function(d, i) {
      return "pt" + i;
    }).attr("r", pointsize).attr("fill", function(d, i) {
      return pointcolor[group[i]];
    }).attr("stroke", pointstroke).attr("stroke-width", "1").attr("opacity", function(d, i) {
      if (((x[i] != null) || xNA.handle) && ((y[i] != null) || yNA.handle)) {
        return 1;
      }
      return 0;
    }).on("mouseover.paneltip", indtip.show).on("mouseout.paneltip", indtip.hide);
  };
  chart.yscale = function() {
    return yscale;
  };
  chart.xscale = function() {
    return xscale;
  };
  chart.points = function() {
    return points;
  };
  chart.svg = function() {
    return svg;
  };
  chart.indtip = function() {
    return indtip;
  };
  chart.remove = function() {
    svg.remove();
    indtip.destroy();
    return null;
  };
  return chart;
};
